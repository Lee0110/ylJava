# 优雅的代码之路

## 设计原则

### 1. 单一职责原则(Single Responsibility Principle SRP)

- 英文描述：A class or module should have a single responsibility. (一个类或者模块只负责完成一个职责(或者功能))

### 2. 开闭原则( Open Closed Principle OCP)

- software entities (modules, classes, functions, etc.) should be open for extension, but closed for modification. (软件实体(模块、类、方法等)应该“对扩展开放、对修改关闭”)

### 3. 里氏替换原则(Liskov Substitution Principle LSP)

- Functions that use pointers of references to base classes must be able to use objects of derived classes without knowing it. (子类对象（object of
  subtype/derived class）能够替换程序（program）中父类对象（object of base/parent
  class）出现的任何地方，并且保证原来程序的逻辑行为（behavior）不变及正确性不被破坏。)

### 4. 接口隔离原则(Interface Segregation Principle ISP)

- Clients should not be forced to depend upon interfaces that they do not use. (客户端不应该强迫依赖它不需要的接口。其中的“客户端”，可以理解为接口的调用者或者使用者。)

### 5. 依赖反转原则(Dependency Inversion Principle DIP)

- High-level modules shouldn’t depend on low-level modules. Both modules should depend on abstractions. In addition, abstractions shouldn’t depend on details. Details depend on abstractions. (高层模块（high-level modules）不要依赖低层模块（low-level）。高层模块和低层模块应该通过抽象（abstractions）来互相依赖。除此之外，抽象（abstractions）不要依赖具体实现细节（details），具体实现细节（details）依赖抽象（abstractions）。)

### 6. KISS原则(Keep It Simple and Stupid)

### 7. YAGNI原则(You Ain't Gonna Need It)

### 8. DRY原则(Don't Repeat Yourself)

### 9. 迪米特原则(Law of Demeter LOD)

## 设计模式

### 1. 单例模式

#### 单例模式需要考虑的问题：

- 构造函数是private的
- 考虑对象创建时的线程安全问题
- 考虑是否延迟加载
- 考虑getInstance()性能是否高

#### 实战案例

##### 一：处理资源访问冲突

这里是搞一个往文件中打印日志的Logger类

```java
public class Logger {
	private FileWriter writer;
	private static final Logger instance = new Logger();
	
	private Logger() {
		File file = new File("/Users/liyulong/log.txt");
		writer = new FileWriter(file, true);
	}
	
	public static Logger getInstance() {
		return instance;
	}
	
	public void log(String message) {
		writer.writer(message);
	}
}
```

##### 二：表示全局唯一类

如果有些数据在系统中只应保存一份，那就比较适合设计为单例类

```java
public class IdGenerator {
	private AtomicLong id = new AtomicLong(0);
	private static final IdGenerator instance = new IdGenerator();
	
	private IdGenerator() {}
	
	public static IdGenerator getInstance() {
		return instance;
	}
	
	public long getId() {
		return id.incrementAndGet();
	}
}
```

#### 如何实现单例

##### 饿汉式

```java
public class IdGenerator {
	private AtomicLong id = new AtomicLong(0);
	private static final IdGenerator instance = new IdGenerator();
	
	private IdGenerator() {}
	
	public static IdGenerator getInstance() {
		return instance;
	}
	
	public long getId() {
		return id.incrementAndGet();
	}
}
```

##### 懒汉式

```java
public class IdGenerator {
	private AtomicLong id = new AtomicLong(0);
	private static IdGenerator instance;
	
	private IdGenerator() {}
	
	public static synchronized IdGenerator getInstance() {
        if (instance == null) {
            instance = new IdGenerator();
        }
        return instance;
	}
	
	public long getId() {
		return id.incrementAndGet();
	}
}
```

##### 双重检测

```java
public class IdGenerator {
	private AtomicLong id = new AtomicLong(0);
	private static volatile IdGenerator instance;
	
	private IdGenerator() {}
	
	public static IdGenerator getInstance() {
        if (instance == null) {
        	synchronized (IdGenerator.class) {
        		if (instance == null) {
        			instance = new IdGenerator();
        		}
        	}
        }
        return instance;
	}
	
	public long getId() {
		return id.incrementAndGet();
	}
}
```

##### 静态内部类

```java
public class IdGenerator {
	private AtomicLong id = new AtomicLong(0);
	
	private IdGenerator() {}
	
	public static class SingletonHolder {
		private static final IdGenerator instance = new IdGenerator();
	}
	
	public static IdGenerator getInstance() {
        return SingletonHolder.instance;
	}
	
	public long getId() {
		return id.incrementAndGet();
	}
}
```

##### 枚举

```java
public enum IdGenerator {
	INSTANCE;
	
	private AtomicLong id = new AtomicLong(0);
	
	public long getId() {
		return id.incrementAndGet();
	}
}
```

#### 单例存在的问题

1. 单例对OOP特性的支持不友好：之前写的IdGenerator违背了基于接口而非实现的设计原则。如果我要订单ID和用户ID用不同的ID生成器，代码改动就比较大。
2. 单例会隐藏类之间依赖关系
3. 单例对代码的扩展性不友好：不好扩展两个实例或多个实例。比如要两个数据库连接池，一个慢SQL，一个其它SQL，单例无法满足要求。
4. 单例对代码的可测试性不友好：无法用mock替换
5. 单例不支持有参数的构造函数

#### 扩展延申

##### 如何理解单例模式的唯一性

##### 如何实现线程唯一的单例

```java
public class IdGenerator {
    private AtomicLong id = new AtomicLong(0);
    
    private static final ConcurrentHashMap<Long, IdGenerator> instances = new ConcurrentHashMap<>();
    
    private IdGenerator() {}
    
    public static IdGenerator getInstance() {
        Long currrntThreadId = Thread.CurrentThread().getId();
        instances.putIfAbsent(currrntThreadId, new IdGenerator());
        return instances.get(currrntThreadId);
    }
    
    public long getId() {
        return id.incrementAndGet();
    }
}
```

### 2. 工厂模式

#### 简单工厂（Simple Factory）

根据配置文件的后缀（json、xml、yaml。。。）选择不同的解析器

##### 第一种实现

```java
public class RuleConfigSource {
	public RuleConfig load(String ruleConfigFilePath) {
        String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);
        IRuleConfigParser parser =  RuleConfigParserFactory.createParser(ruleConfigFileExtension);
        if (parser == null) {
            throw new InvalidRuleConfigException(
            "Rule config file format is not supported: " + ruleConfigFilePath);
        }
        
        String configText = "";
        //从ruleConfigFilePath文件中读取配置文本到configText中
        RuleConfig ruleConfig = parser.parse(configText);
        return ruleConfig;
    }
    
    private String getFileExtension(String filePath) {
        // TODO 解析文件名获取扩展名，比如rule.json，返回json
		return "json";
    }
}

public class RuleConfigParserFactory {
    public static IRuleConfigParser createParser(String configFormat) {
        IRuleConfigParser parser = null;
        if ("json".equalsIgnoreCase(configFormat)) {
        	parser = new JsonRuleConfigParser();
        } else if ("xml".equalsIgnoreCase(configFormat)) {
        	parser = new XmlRuleConfigParser();
        } else if ("yaml".equalsIgnoreCase(configFormat)) {
        	parser = new YamlRuleConfigParser();
        } else if ("properties".equalsIgnoreCase(configFormat)) {
        	parser = new PropertiesRuleConfigParser();
        }
        return parser;
    }
}
```

##### 第二种实现

```java
public class RuleConfigParserFactory {
    private static final Map<String, RuleConfigParser> cachedParsers = new HashMap<String, RuleConfigParser>();
    
    static {
        cachedParsers.put("json", new JsonRuleConfigParser());
        cachedParsers.put("xml", new XmlRuleConfigParser());
        cachedParsers.put("yaml", new YamlRuleConfigParser());
        cachedParsers.put("properties", new PropertiesRuleConfigParser());
    }
    
    public static IRuleConfigParser createParser(String configFormat) {
    if (configFormat == null || configFormat.isEmpty()) {
    	return null; // 返回null还是IllegalArgumentException全凭你自己说了算
    }
        
    IRuleConfigParser parser = cachedParsers.get(configFormat.toLowerCase());
    return parser;
    }
}
```

#### 工厂方法（Factory Method）

为工厂类再创建一个简单工厂，也就是工厂的工厂，用来创建工厂类对象。

```java
public class RuleConfigSource {
    public RuleConfig load(String ruleConfigFilePath) {
        String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);
        IRuleConfigParserFactory parserFactory = RuleConfigParserFactoryMap.getParserFactory(ruleConfigFileExtension);
        
        if (parserFactory == null) {
        	throw new InvalidRuleConfigException("Rule config file format is not supported: " + ruleConfigFilePath);
        }
        IRuleConfigParser parser = parserFactory.createParser();
        String configText = "";
        //从ruleConfigFilePath文件中读取配置文本到configText中
        RuleConfig ruleConfig = parser.parse(configText);
        return ruleConfig;
    }
                                         
    private String getFileExtension(String filePath) {
    //...解析文件名获取扩展名，比如rule.json，返回json
    return "json";
    }
}
                                     
//因为工厂类只包含方法，不包含成员变量，完全可以复用，
//不需要每次都创建新的工厂类对象，所以，简单工厂模式的第二种实现思路更加合适。
public class RuleConfigParserFactoryMap { //工厂的工厂
    private static final Map<String, IRuleConfigParserFactory> cachedFactories = new Map<String, IRuleConfigParserFactory> ();
    static {
        cachedFactories.put("json", new JsonRuleConfigParserFactory());
        cachedFactories.put("xml", new XmlRuleConfigParserFactory());
        cachedFactories.put("yaml", new YamlRuleConfigParserFactory());
        cachedFactories.put("properties", new PropertiesRuleConfigParserFactory())
    }
    
    public static IRuleConfigParserFactory getParserFactory(String type) {
        if (type == null || type.isEmpty()) {
        	return null;
        }
        IRuleConfigParserFactory parserFactory = cachedFactories.get(type.toLowerCase());
        return parserFactory;
    }
}
```

当对象的创建逻辑比较复杂，不只是简单的 new 一下就可以，而是要 组合其他类对象，做各种初始化操作的时候，我们推荐使用工厂方法模式，将复杂的创建逻 辑拆分到多个工厂类中，让每个工厂类都不至于过于复杂。而使用简单工厂模式，将所有的 创建逻辑都放到一个工厂类中，会导致这个工厂类变得很复杂。 除此之外，在某些场景下，如果对象不可复用，那工厂类每次都要返回不同的对象。如果我 们使用简单工厂模式来实现，就只能选择第一种包含 if 分支逻辑的实现方式。如果我们还 想避免烦人的 if-else 分支逻辑，这个时候，我们就推荐使用工厂方法模式。

#### 抽象工厂（Abstract Factory）

在简单工厂和工厂方法中，类只有一种分类方式。比如，在规则配置解析那个例子中，解析器类只会根据配置文件格式（Json、Xml、Yaml……）来分类。但是，如果类有两种分类方式，比如，我们既可以按照配置文件格式来分类，也可以按照解析的对象（Rule 规则配置 还是 System 系统配置）来分类，那就会有 8 个 parser 类。

```java
public interface IConfigParserFactory {
    IRuleConfigParser createRuleParser();
    ISystemConfigParser createSystemParser();
    //此处可以扩展新的parser类型，比如IBizConfigParser
}

public class JsonConfigParserFactory implements IConfigParserFactory {
    @Override
    public IRuleConfigParser createRuleParser() {
    	return new JsonRuleConfigParser();
    }
    
    @Override
    public ISystemConfigParser createSystemParser() {
    	return new JsonSystemConfigParser();
    }
}

public class XmlConfigParserFactory implements IConfigParserFactory {
    @Override
    public IRuleConfigParser createRuleParser() {
    	return new XmlRuleConfigParser();
	}
    
    @Override
    public ISystemConfigParser createSystemParser() {
    	return new XmlSystemConfigParser();
    }
}
```

#### 工厂模式作用

- 封装变化：创建逻辑有可能变化，封装成工厂类之后，创建逻辑的变更对调用者透明。
- 代码复用：创建代码抽离到独立的工厂类之后可以复用。 
- 隔离复杂性：封装复杂的创建逻辑，调用者无需了解如何创建对象。 
- 控制复杂度：将创建代码抽离出来，让原本的函数或类职责更单一，代码更简洁。

#### 工厂模式使用总结

当创建逻辑比较复杂，是一个“大工程”的时候，我们就考虑使用工厂模式，封装对象的创 建过程，将对象的创建和使用相分离。何为创建逻辑比较复杂呢？我总结了下面两种情况。

- 第一种情况：类似规则配置解析的例子，代码中存在 if-else 分支判断，动态地根据不同 的类型创建不同的对象。针对这种情况，我们就考虑使用工厂模式，将这一大坨 if-else 创建对象的代码抽离出来，放到工厂类中。
- 第二种情况，尽管我们不需要根据不同的类型创建不同的对象，但是，单个对象本身 的创建过程比较复杂，比如前面提到的要组合其他类对象，做各种初始化操作。在这种 情况下，我们也可以考虑使用工厂模式，将对象的创建过程封装到工厂类中。

对于第一种情况，当每个对象的创建逻辑都比较简单的时候，我推荐使用简单工厂模式，将 多个对象的创建逻辑放到一个工厂类中。当每个对象的创建逻辑都比较复杂的时候，为了避 免设计一个过于庞大的简单工厂类，我推荐使用工厂方法模式，将创建逻辑拆分得更细，每 个对象的创建逻辑独立到各自的工厂类中。同理，对于第二种情况，因为单个对象本身的创 建逻辑就比较复杂，所以，我建议使用工厂方法模式。

如果创建对象的逻辑并不复杂，那我们就直接通过 new 来创建对象就可以了，不需要使用工厂模式。
