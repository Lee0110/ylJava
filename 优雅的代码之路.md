# 优雅的代码之路

## 设计原则

### 1. 单一职责原则(Single Responsibility Principle SRP)

- 英文描述：A class or module should have a single responsibility. (一个类或者模块只负责完成一个职责(或者功能))

### 2. 开闭原则( Open Closed Principle OCP)

- software entities (modules, classes, functions, etc.) should be open for extension, but closed for modification. (软件实体(模块、类、方法等)应该“对扩展开放、对修改关闭”)

### 3. 里氏替换原则(Liskov Substitution Principle LSP)

- Functions that use pointers of references to base classes must be able to use objects of derived classes without knowing it. (子类对象（object of
  subtype/derived class）能够替换程序（program）中父类对象（object of base/parent
  class）出现的任何地方，并且保证原来程序的逻辑行为（behavior）不变及正确性不被破坏。)

### 4. 接口隔离原则(Interface Segregation Principle ISP)

- Clients should not be forced to depend upon interfaces that they do not use. (客户端不应该强迫依赖它不需要的接口。其中的“客户端”，可以理解为接口的调用者或者使用者。)

### 5. 依赖反转原则(Dependency Inversion Principle DIP)

- High-level modules shouldn’t depend on low-level modules. Both modules should depend on abstractions. In addition, abstractions shouldn’t depend on details. Details depend on abstractions. (高层模块（high-level modules）不要依赖低层模块（low-level）。高层模块和低层模块应该通过抽象（abstractions）来互相依赖。除此之外，抽象（abstractions）不要依赖具体实现细节（details），具体实现细节（details）依赖抽象（abstractions）。)

### 6. KISS原则(Keep It Simple and Stupid)

### 7. YAGNI原则(You Ain't Gonna Need It)

### 8. DRY原则(Don't Repeat Yourself)

### 9. 迪米特原则(Law of Demeter LOD)

## 设计模式

### 创建型模式

#### 1. 单例模式

##### 单例模式需要考虑的问题：

- 构造函数是private的
- 考虑对象创建时的线程安全问题
- 考虑是否延迟加载
- 考虑getInstance()性能是否高

##### 实战案例

###### 一：处理资源访问冲突

这里是搞一个往文件中打印日志的Logger类

```java
public class Logger {
	private FileWriter writer;
	private static final Logger instance = new Logger();
	
	private Logger() {
		File file = new File("/Users/liyulong/log.txt");
		writer = new FileWriter(file, true);
	}
	
	public static Logger getInstance() {
		return instance;
	}
	
	public void log(String message) {
		writer.writer(message);
	}
}
```

###### 二：表示全局唯一类

如果有些数据在系统中只应保存一份，那就比较适合设计为单例类

```java
public class IdGenerator {
	private AtomicLong id = new AtomicLong(0);
	private static final IdGenerator instance = new IdGenerator();
	
	private IdGenerator() {}
	
	public static IdGenerator getInstance() {
		return instance;
	}
	
	public long getId() {
		return id.incrementAndGet();
	}
}
```

##### 如何实现单例

###### 饿汉式

```java
public class IdGenerator {
	private AtomicLong id = new AtomicLong(0);
	private static final IdGenerator instance = new IdGenerator();
	
	private IdGenerator() {}
	
	public static IdGenerator getInstance() {
		return instance;
	}
	
	public long getId() {
		return id.incrementAndGet();
	}
}
```

###### 懒汉式

```java
public class IdGenerator {
	private AtomicLong id = new AtomicLong(0);
	private static IdGenerator instance;
	
	private IdGenerator() {}
	
	public static synchronized IdGenerator getInstance() {
        if (instance == null) {
            instance = new IdGenerator();
        }
        return instance;
	}
	
	public long getId() {
		return id.incrementAndGet();
	}
}
```

###### 双重检测

```java
public class IdGenerator {
	private AtomicLong id = new AtomicLong(0);
	private static volatile IdGenerator instance;
	
	private IdGenerator() {}
	
	public static IdGenerator getInstance() {
        if (instance == null) {
        	synchronized (IdGenerator.class) {
        		if (instance == null) {
        			instance = new IdGenerator();
        		}
        	}
        }
        return instance;
	}
	
	public long getId() {
		return id.incrementAndGet();
	}
}
```

###### 静态内部类

```java
public class IdGenerator {
	private AtomicLong id = new AtomicLong(0);
	
	private IdGenerator() {}
	
	public static class SingletonHolder {
		private static final IdGenerator instance = new IdGenerator();
	}
	
	public static IdGenerator getInstance() {
        return SingletonHolder.instance;
	}
	
	public long getId() {
		return id.incrementAndGet();
	}
}
```

###### 枚举

```java
public enum IdGenerator {
	INSTANCE;
	
	private AtomicLong id = new AtomicLong(0);
	
	public long getId() {
		return id.incrementAndGet();
	}
}
```

##### 单例存在的问题

1. 单例对OOP特性的支持不友好：之前写的IdGenerator违背了基于接口而非实现的设计原则。如果我要订单ID和用户ID用不同的ID生成器，代码改动就比较大。
2. 单例会隐藏类之间依赖关系
3. 单例对代码的扩展性不友好：不好扩展两个实例或多个实例。比如要两个数据库连接池，一个慢SQL，一个其它SQL，单例无法满足要求。
4. 单例对代码的可测试性不友好：无法用mock替换
5. 单例不支持有参数的构造函数

##### 扩展延申

###### 如何理解单例模式的唯一性

###### 如何实现线程唯一的单例

```java
public class IdGenerator {
    private AtomicLong id = new AtomicLong(0);
    
    private static final ConcurrentHashMap<Long, IdGenerator> instances = new ConcurrentHashMap<>();
    
    private IdGenerator() {}
    
    public static IdGenerator getInstance() {
        Long currrntThreadId = Thread.CurrentThread().getId();
        instances.putIfAbsent(currrntThreadId, new IdGenerator());
        return instances.get(currrntThreadId);
    }
    
    public long getId() {
        return id.incrementAndGet();
    }
}
```

#### 2. 工厂模式

##### 简单工厂（Simple Factory）

根据配置文件的后缀（json、xml、yaml。。。）选择不同的解析器

###### 第一种实现

```java
public class RuleConfigSource {
	public RuleConfig load(String ruleConfigFilePath) {
        String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);
        IRuleConfigParser parser =  RuleConfigParserFactory.createParser(ruleConfigFileExtension);
        if (parser == null) {
            throw new InvalidRuleConfigException(
            "Rule config file format is not supported: " + ruleConfigFilePath);
        }
        
        String configText = "";
        //从ruleConfigFilePath文件中读取配置文本到configText中
        RuleConfig ruleConfig = parser.parse(configText);
        return ruleConfig;
    }
    
    private String getFileExtension(String filePath) {
        // TODO 解析文件名获取扩展名，比如rule.json，返回json
		return "json";
    }
}

public class RuleConfigParserFactory {
    public static IRuleConfigParser createParser(String configFormat) {
        IRuleConfigParser parser = null;
        if ("json".equalsIgnoreCase(configFormat)) {
        	parser = new JsonRuleConfigParser();
        } else if ("xml".equalsIgnoreCase(configFormat)) {
        	parser = new XmlRuleConfigParser();
        } else if ("yaml".equalsIgnoreCase(configFormat)) {
        	parser = new YamlRuleConfigParser();
        } else if ("properties".equalsIgnoreCase(configFormat)) {
        	parser = new PropertiesRuleConfigParser();
        }
        return parser;
    }
}
```

###### 第二种实现

```java
public class RuleConfigParserFactory {
    private static final Map<String, RuleConfigParser> cachedParsers = new HashMap<String, RuleConfigParser>();
    
    static {
        cachedParsers.put("json", new JsonRuleConfigParser());
        cachedParsers.put("xml", new XmlRuleConfigParser());
        cachedParsers.put("yaml", new YamlRuleConfigParser());
        cachedParsers.put("properties", new PropertiesRuleConfigParser());
    }
    
    public static IRuleConfigParser createParser(String configFormat) {
    if (configFormat == null || configFormat.isEmpty()) {
    	return null; // 返回null还是IllegalArgumentException全凭你自己说了算
    }
        
    IRuleConfigParser parser = cachedParsers.get(configFormat.toLowerCase());
    return parser;
    }
}
```

##### 工厂方法（Factory Method）

为工厂类再创建一个简单工厂，也就是工厂的工厂，用来创建工厂类对象。

```java
public class RuleConfigSource {
    public RuleConfig load(String ruleConfigFilePath) {
        String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);
        IRuleConfigParserFactory parserFactory = RuleConfigParserFactoryMap.getParserFactory(ruleConfigFileExtension);
        
        if (parserFactory == null) {
        	throw new InvalidRuleConfigException("Rule config file format is not supported: " + ruleConfigFilePath);
        }
        IRuleConfigParser parser = parserFactory.createParser();
        String configText = "";
        //从ruleConfigFilePath文件中读取配置文本到configText中
        RuleConfig ruleConfig = parser.parse(configText);
        return ruleConfig;
    }
                                         
    private String getFileExtension(String filePath) {
    //...解析文件名获取扩展名，比如rule.json，返回json
    return "json";
    }
}
                                     
//因为工厂类只包含方法，不包含成员变量，完全可以复用，
//不需要每次都创建新的工厂类对象，所以，简单工厂模式的第二种实现思路更加合适。
public class RuleConfigParserFactoryMap { //工厂的工厂
    private static final Map<String, IRuleConfigParserFactory> cachedFactories = new Map<String, IRuleConfigParserFactory> ();
    static {
        cachedFactories.put("json", new JsonRuleConfigParserFactory());
        cachedFactories.put("xml", new XmlRuleConfigParserFactory());
        cachedFactories.put("yaml", new YamlRuleConfigParserFactory());
        cachedFactories.put("properties", new PropertiesRuleConfigParserFactory())
    }
    
    public static IRuleConfigParserFactory getParserFactory(String type) {
        if (type == null || type.isEmpty()) {
        	return null;
        }
        IRuleConfigParserFactory parserFactory = cachedFactories.get(type.toLowerCase());
        return parserFactory;
    }
}
```

当对象的创建逻辑比较复杂，不只是简单的 new 一下就可以，而是要 组合其他类对象，做各种初始化操作的时候，我们推荐使用工厂方法模式，将复杂的创建逻 辑拆分到多个工厂类中，让每个工厂类都不至于过于复杂。而使用简单工厂模式，将所有的 创建逻辑都放到一个工厂类中，会导致这个工厂类变得很复杂。 除此之外，在某些场景下，如果对象不可复用，那工厂类每次都要返回不同的对象。如果我 们使用简单工厂模式来实现，就只能选择第一种包含 if 分支逻辑的实现方式。如果我们还 想避免烦人的 if-else 分支逻辑，这个时候，我们就推荐使用工厂方法模式。

##### 抽象工厂（Abstract Factory）

在简单工厂和工厂方法中，类只有一种分类方式。比如，在规则配置解析那个例子中，解析器类只会根据配置文件格式（Json、Xml、Yaml……）来分类。但是，如果类有两种分类方式，比如，我们既可以按照配置文件格式来分类，也可以按照解析的对象（Rule 规则配置 还是 System 系统配置）来分类，那就会有 8 个 parser 类。

```java
public interface IConfigParserFactory {
    IRuleConfigParser createRuleParser();
    ISystemConfigParser createSystemParser();
    //此处可以扩展新的parser类型，比如IBizConfigParser
}

public class JsonConfigParserFactory implements IConfigParserFactory {
    @Override
    public IRuleConfigParser createRuleParser() {
    	return new JsonRuleConfigParser();
    }
    
    @Override
    public ISystemConfigParser createSystemParser() {
    	return new JsonSystemConfigParser();
    }
}

public class XmlConfigParserFactory implements IConfigParserFactory {
    @Override
    public IRuleConfigParser createRuleParser() {
    	return new XmlRuleConfigParser();
	}
    
    @Override
    public ISystemConfigParser createSystemParser() {
    	return new XmlSystemConfigParser();
    }
}
```

##### 工厂模式作用

- 封装变化：创建逻辑有可能变化，封装成工厂类之后，创建逻辑的变更对调用者透明。
- 代码复用：创建代码抽离到独立的工厂类之后可以复用。 
- 隔离复杂性：封装复杂的创建逻辑，调用者无需了解如何创建对象。 
- 控制复杂度：将创建代码抽离出来，让原本的函数或类职责更单一，代码更简洁。

##### 工厂模式使用总结

当创建逻辑比较复杂，是一个“大工程”的时候，我们就考虑使用工厂模式，封装对象的创 建过程，将对象的创建和使用相分离。何为创建逻辑比较复杂呢？我总结了下面两种情况。

- 第一种情况：类似规则配置解析的例子，代码中存在 if-else 分支判断，动态地根据不同 的类型创建不同的对象。针对这种情况，我们就考虑使用工厂模式，将这一大坨 if-else 创建对象的代码抽离出来，放到工厂类中。
- 第二种情况，尽管我们不需要根据不同的类型创建不同的对象，但是，单个对象本身 的创建过程比较复杂，比如前面提到的要组合其他类对象，做各种初始化操作。在这种 情况下，我们也可以考虑使用工厂模式，将对象的创建过程封装到工厂类中。

对于第一种情况，当每个对象的创建逻辑都比较简单的时候，我推荐使用简单工厂模式，将 多个对象的创建逻辑放到一个工厂类中。当每个对象的创建逻辑都比较复杂的时候，为了避 免设计一个过于庞大的简单工厂类，我推荐使用工厂方法模式，将创建逻辑拆分得更细，每 个对象的创建逻辑独立到各自的工厂类中。同理，对于第二种情况，因为单个对象本身的创 建逻辑就比较复杂，所以，我建议使用工厂方法模式。

如果创建对象的逻辑并不复杂，那我们就直接通过 new 来创建对象就可以了，不需要使用工厂模式。

#### 3. 建造者模式

我们需要定义一个资源池配置类 ResourcePoolConfig。这里的资源池，你可以简单理解为线程池、连接池、对象池等。在这个资源池配置类中，有以下几个成员变量，也就是可配置项。现在，请你编写代码实现这个 ResourcePoolConfig 类。

可以直接使用构造函数。如果参数过多，构造函数里传入必填参数，其他的用set方法。如果必填参数过多，用建造者模式。

```java
public class ResourcePoolConfig {
    private String name;
    private int maxTotal;
    private int maxIdle;
    private int minIdle;
    	
    private ResourcePoolConfig(Builder builder) {
        this.name = builder.name;
        this.maxTotal = builder.maxTotal;
        this.maxIdle = builder.maxIdle;
        this.minIdle = builder.minIdle;
    }
    //...省略getter方法...
    //我们将Builder类设计成了ResourcePoolConfig的内部类。
    //我们也可以将Builder类设计成独立的非内部类ResourcePoolConfigBuilder。
    public static class Builder {
        private static final int DEFAULT_MAX_TOTAL = 8;
        private static final int DEFAULT_MAX_IDLE = 8;
        private static final int DEFAULT_MIN_IDLE = 0;

        private String name;
        private int maxTotal = DEFAULT_MAX_TOTAL;
        private int maxIdle = DEFAULT_MAX_IDLE;
        private int minIdle = DEFAULT_MIN_IDLE;

        public ResourcePoolConfig build() {
            // 校验逻辑放到这里来做，包括必填项校验、依赖关系校验、约束条件校验等
            if (StringUtils.isBlank(name)) {
                    throw new IllegalArgumentException("...");
            }
            if (maxIdle > maxTotal) {
                throw new IllegalArgumentException("...");
            }
            if (minIdle > maxTotal || minIdle > maxIdle) {
                throw new IllegalArgumentException("...");
            }
            return new ResourcePoolConfig(this);
        }
        
        public Builder setName(String name) {
            if (StringUtils.isBlank(name)) {
            	throw new IllegalArgumentException("...");
            }
            this.name = name;
            return this;
        }
        
        public Builder setMaxTotal(int maxTotal) {
            if (maxTotal <= 0) {
            	throw new IllegalArgumentException("...");
            }
            this.maxTotal = maxTotal;
            return this;
        }
        
        public Builder setMaxIdle(int maxIdle) {
            if (maxIdle < 0) {
            	throw new IllegalArgumentException("...");
            }
            this.maxIdle = maxIdle;
            return this;
        }
        
        public Builder setMinIdle(int minIdle) {
            if (minIdle < 0) {
            	throw new IllegalArgumentException("...");
            }
            this.minIdle = minIdle;
            return this;
        }
    }
}

// 这段代码会抛出IllegalArgumentException，因为minIdle>maxIdle
ResourcePoolConfig config = new ResourcePoolConfig.Builder()
.setName("dbconnectionpool")
.setMaxTotal(16)
.setMaxIdle(10)
.setMinIdle(12)
.build();
```

#### 4. 原型模式

##### 原理和应用

如果对象的创建成本比较大，而同一个类的不同对象之间差别不大（大部分字段都相同），在这种情况下，我们可以利用对已有对象（原型）进行复制（或者叫拷贝）的方式来创建新对象，以达到节省创建时间的目的。这种基于原型来创建对象的方式就叫作原型设计模式（Prototype Design Pattern），简称原型模式。

##### 何为创建成本大

实际上，创建对象包含的申请内存、给成员变量赋值这一过程，本身并不会花费太多时间， 或者说对于大部分业务系统来说，这点时间完全是可以忽略的。应用一个复杂的模式，只得 到一点点的性能提升，这就是所谓的过度设计，得不偿失。 但是，如果对象中的数据需要经过复杂的计算才能得到（比如排序、计算哈希值），或者需 要从 RPC、网络、数据库、文件系统等非常慢速的 IO 中读取，这种情况下，我们就可以利 用原型模式，从其他已有对象中直接拷贝得到，而不用每次在创建新对象的时候，都重复执 行这些耗时的操作。

##### 原型模式的实现方式：深拷贝和浅拷贝

浅拷贝和深拷贝的区别在于，浅拷贝只会复制图中的索引（散列表），不会复制数据（SearchWord 对象）本身。相反，深拷贝不仅仅会复制索引，还会复制数据本身。浅拷贝得到的对象（newKeywords）跟原始对象（currentKeywords）共享数据（SearchWord 对象），而深拷贝得到的是一份完完全全独立的对象。

##### 深拷贝的实现

###### 第一种: 递归

递归拷贝对象、对象的引用对象以及引用对象的引用对象……直到要拷贝的对 象只包含基本数据类型数据，没有引用对象为止。

```java
public class Demo {
    private HashMap<String, SearchWord> currentKeywords=new HashMap<>();
    private long lastUpdateTime = -1;
    
    public void refresh() {
        // Deep copy
        HashMap<String, SearchWord> newKeywords = new HashMap<>();
        for (HashMap.Entry<String, SearchWord> e : currentKeywords.entrySet()) {
            SearchWord searchWord = e.getValue();
            SearchWord newSearchWord = new SearchWord(
            searchWord.getKeyword(), searchWord.getCount(), searchWord.getLas
            newKeywords.put(e.getKey(), newSearchWord);
    	}
                
        // 从数据库中取出更新时间>lastUpdateTime的数据，放入到newKeywords中
        List<SearchWord> toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);
        long maxNewUpdatedTime = lastUpdateTime;
        for (SearchWord searchWord : toBeUpdatedSearchWords) {
            if (searchWord.getLastUpdateTime() > maxNewUpdatedTime) {
                maxNewUpdatedTime = searchWord.getLastUpdateTime();
            }
            if (newKeywords.containsKey(searchWord.getKeyword())) {
                SearchWord oldSearchWord = newKeywords.get(searchWord.getKeyword());
                oldSearchWord.setCount(searchWord.getCount());
                oldSearchWord.setLastUpdateTime(searchWord.getLastUpdateTime());
            } else {
                newKeywords.put(searchWord.getKeyword(), searchWord);
            }
        }
                
        lastUpdateTime = maxNewUpdatedTime;
        currentKeywords = newKeywords;
    }
            
    private List<SearchWord> getSearchWords(long lastUpdateTime) {
        // TODO: 从数据库中取出更新时间>lastUpdateTime的数据
        return null;
    }
}
```

###### 第二种方法：先将对象序列化，然后再反序列化成新的对象。

```java
public Object deepCopy(Object object) {
    ByteArrayOutputStream bo = new ByteArrayOutputStream();
    ObjectOutputStream oo = new ObjectOutputStream(bo);
    oo.writeObject(object);
    ByteArrayInputStream bi = new ByteArrayInputStream(bo.toByteArray());
    ObjectInputStream oi = new ObjectInputStream(bi);
    return oi.readObject();
}
```

##### 浅拷贝和深拷贝结合的方法, 更快, 更省空间

先用浅拷贝, 需要更新的就用深拷贝创建新的对象, 替换原来的老对象.

```java
public class Demo {
    private HashMap<String, SearchWord> currentKeywords=new HashMap<>();
    private long lastUpdateTime = -1;
    
    public void refresh() {
        // Shallow copy
        HashMap<String, SearchWord> newKeywords = (HashMap<String, SearchWord>) currentKeywords.clone();
        // 从数据库中取出更新时间>lastUpdateTime的数据，放入到newKeywords中
        List<SearchWord> toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);
        long maxNewUpdatedTime = lastUpdateTime;
        for (SearchWord searchWord : toBeUpdatedSearchWords) {
            if (searchWord.getLastUpdateTime() > maxNewUpdatedTime) {
            	maxNewUpdatedTime = searchWord.getLastUpdateTime();
            }
            if (newKeywords.containsKey(searchWord.getKeyword())) {
            	newKeywords.remove(searchWord.getKeyword());
            }
            newKeywords.put(searchWord.getKeyword(), searchWord);
        }
        lastUpdateTime = maxNewUpdatedTime;
        currentKeywords = newKeywords;
    }
    
    private List<SearchWord> getSearchWords(long lastUpdateTime) {
        // TODO: 从数据库中取出更新时间>lastUpdateTime的数据
        return null;
    }
}
```

