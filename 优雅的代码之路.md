# 优雅的代码之路

设计模式之美学习笔记

## 设计原则

### 1. 单一职责原则(Single Responsibility Principle SRP)

- 英文描述：A class or module should have a single responsibility. (一个类或者模块只负责完成一个职责(或者功能))

### 2. 开闭原则( Open Closed Principle OCP)

- software entities (modules, classes, functions, etc.) should be open for extension, but closed for modification. (软件实体(模块、类、方法等)应该“对扩展开放、对修改关闭”)

### 3. 里氏替换原则(Liskov Substitution Principle LSP)

- Functions that use pointers of references to base classes must be able to use objects of derived classes without knowing it. (子类对象（object of
  subtype/derived class）能够替换程序（program）中父类对象（object of base/parent
  class）出现的任何地方，并且保证原来程序的逻辑行为（behavior）不变及正确性不被破坏。)

### 4. 接口隔离原则(Interface Segregation Principle ISP)

- Clients should not be forced to depend upon interfaces that they do not use. (客户端不应该强迫依赖它不需要的接口。其中的“客户端”，可以理解为接口的调用者或者使用者。)

### 5. 依赖反转原则(Dependency Inversion Principle DIP)

- High-level modules shouldn’t depend on low-level modules. Both modules should depend on abstractions. In addition, abstractions shouldn’t depend on details. Details depend on abstractions. (高层模块（high-level modules）不要依赖低层模块（low-level）。高层模块和低层模块应该通过抽象（abstractions）来互相依赖。除此之外，抽象（abstractions）不要依赖具体实现细节（details），具体实现细节（details）依赖抽象（abstractions）。)

### 6. KISS原则(Keep It Simple and Stupid)

### 7. YAGNI原则(You Ain't Gonna Need It)

### 8. DRY原则(Don't Repeat Yourself)

### 9. 迪米特原则(Law of Demeter LOD)

## 设计模式

### 创建型模式

#### 1. 单例模式

##### 单例模式需要考虑的问题：

- 构造函数是private的
- 考虑对象创建时的线程安全问题
- 考虑是否延迟加载
- 考虑getInstance()性能是否高

##### 实战案例

###### 一：处理资源访问冲突

这里是搞一个往文件中打印日志的Logger类

```java
public class Logger {
	private FileWriter writer;
	private static final Logger instance = new Logger();
	
	private Logger() {
		File file = new File("/Users/liyulong/log.txt");
		writer = new FileWriter(file, true);
	}
	
	public static Logger getInstance() {
		return instance;
	}
	
	public void log(String message) {
		writer.writer(message);
	}
}
```

###### 二：表示全局唯一类

如果有些数据在系统中只应保存一份，那就比较适合设计为单例类

```java
public class IdGenerator {
	private AtomicLong id = new AtomicLong(0);
	private static final IdGenerator instance = new IdGenerator();
	
	private IdGenerator() {}
	
	public static IdGenerator getInstance() {
		return instance;
	}
	
	public long getId() {
		return id.incrementAndGet();
	}
}
```

##### 如何实现单例

###### 饿汉式

```java
public class IdGenerator {
	private AtomicLong id = new AtomicLong(0);
	private static final IdGenerator instance = new IdGenerator();
	
	private IdGenerator() {}
	
	public static IdGenerator getInstance() {
		return instance;
	}
	
	public long getId() {
		return id.incrementAndGet();
	}
}
```

###### 懒汉式

```java
public class IdGenerator {
	private AtomicLong id = new AtomicLong(0);
	private static IdGenerator instance;
	
	private IdGenerator() {}
	
	public static synchronized IdGenerator getInstance() {
        if (instance == null) {
            instance = new IdGenerator();
        }
        return instance;
	}
	
	public long getId() {
		return id.incrementAndGet();
	}
}
```

###### 双重检测

```java
public class IdGenerator {
	private AtomicLong id = new AtomicLong(0);
	private static volatile IdGenerator instance;
	
	private IdGenerator() {}
	
	public static IdGenerator getInstance() {
        if (instance == null) {
        	synchronized (IdGenerator.class) {
        		if (instance == null) {
        			instance = new IdGenerator();
        		}
        	}
        }
        return instance;
	}
	
	public long getId() {
		return id.incrementAndGet();
	}
}
```

###### 静态内部类

```java
public class IdGenerator {
	private AtomicLong id = new AtomicLong(0);
	
	private IdGenerator() {}
	
	public static class SingletonHolder {
		private static final IdGenerator instance = new IdGenerator();
	}
	
	public static IdGenerator getInstance() {
        return SingletonHolder.instance;
	}
	
	public long getId() {
		return id.incrementAndGet();
	}
}
```

###### 枚举

```java
public enum IdGenerator {
	INSTANCE;
	
	private AtomicLong id = new AtomicLong(0);
	
	public long getId() {
		return id.incrementAndGet();
	}
}
```

##### 单例存在的问题

1. 单例对OOP特性的支持不友好：之前写的IdGenerator违背了基于接口而非实现的设计原则。如果我要订单ID和用户ID用不同的ID生成器，代码改动就比较大。
2. 单例会隐藏类之间依赖关系
3. 单例对代码的扩展性不友好：不好扩展两个实例或多个实例。比如要两个数据库连接池，一个慢SQL，一个其它SQL，单例无法满足要求。
4. 单例对代码的可测试性不友好：无法用mock替换
5. 单例不支持有参数的构造函数

##### 扩展延申

###### 如何理解单例模式的唯一性

###### 如何实现线程唯一的单例

```java
public class IdGenerator {
    private AtomicLong id = new AtomicLong(0);
    
    private static final ConcurrentHashMap<Long, IdGenerator> instances = new ConcurrentHashMap<>();
    
    private IdGenerator() {}
    
    public static IdGenerator getInstance() {
        Long currrntThreadId = Thread.CurrentThread().getId();
        instances.putIfAbsent(currrntThreadId, new IdGenerator());
        return instances.get(currrntThreadId);
    }
    
    public long getId() {
        return id.incrementAndGet();
    }
}
```

#### 2. 工厂模式

##### 简单工厂（Simple Factory）

根据配置文件的后缀（json、xml、yaml。。。）选择不同的解析器

###### 第一种实现

```java
public class RuleConfigSource {
	public RuleConfig load(String ruleConfigFilePath) {
        String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);
        IRuleConfigParser parser =  RuleConfigParserFactory.createParser(ruleConfigFileExtension);
        if (parser == null) {
            throw new InvalidRuleConfigException(
            "Rule config file format is not supported: " + ruleConfigFilePath);
        }
        
        String configText = "";
        //从ruleConfigFilePath文件中读取配置文本到configText中
        RuleConfig ruleConfig = parser.parse(configText);
        return ruleConfig;
    }
    
    private String getFileExtension(String filePath) {
        // TODO 解析文件名获取扩展名，比如rule.json，返回json
		return "json";
    }
}

public class RuleConfigParserFactory {
    public static IRuleConfigParser createParser(String configFormat) {
        IRuleConfigParser parser = null;
        if ("json".equalsIgnoreCase(configFormat)) {
        	parser = new JsonRuleConfigParser();
        } else if ("xml".equalsIgnoreCase(configFormat)) {
        	parser = new XmlRuleConfigParser();
        } else if ("yaml".equalsIgnoreCase(configFormat)) {
        	parser = new YamlRuleConfigParser();
        } else if ("properties".equalsIgnoreCase(configFormat)) {
        	parser = new PropertiesRuleConfigParser();
        }
        return parser;
    }
}
```

###### 第二种实现

```java
public class RuleConfigParserFactory {
    private static final Map<String, RuleConfigParser> cachedParsers = new HashMap<String, RuleConfigParser>();
    
    static {
        cachedParsers.put("json", new JsonRuleConfigParser());
        cachedParsers.put("xml", new XmlRuleConfigParser());
        cachedParsers.put("yaml", new YamlRuleConfigParser());
        cachedParsers.put("properties", new PropertiesRuleConfigParser());
    }
    
    public static IRuleConfigParser createParser(String configFormat) {
    if (configFormat == null || configFormat.isEmpty()) {
    	return null; // 返回null还是IllegalArgumentException全凭你自己说了算
    }
        
    IRuleConfigParser parser = cachedParsers.get(configFormat.toLowerCase());
    return parser;
    }
}
```

##### 工厂方法（Factory Method）

为工厂类再创建一个简单工厂，也就是工厂的工厂，用来创建工厂类对象。

```java
public class RuleConfigSource {
    public RuleConfig load(String ruleConfigFilePath) {
        String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);
        IRuleConfigParserFactory parserFactory = RuleConfigParserFactoryMap.getParserFactory(ruleConfigFileExtension);
        
        if (parserFactory == null) {
        	throw new InvalidRuleConfigException("Rule config file format is not supported: " + ruleConfigFilePath);
        }
        IRuleConfigParser parser = parserFactory.createParser();
        String configText = "";
        //从ruleConfigFilePath文件中读取配置文本到configText中
        RuleConfig ruleConfig = parser.parse(configText);
        return ruleConfig;
    }
                                         
    private String getFileExtension(String filePath) {
    //...解析文件名获取扩展名，比如rule.json，返回json
    return "json";
    }
}
                                     
//因为工厂类只包含方法，不包含成员变量，完全可以复用，
//不需要每次都创建新的工厂类对象，所以，简单工厂模式的第二种实现思路更加合适。
public class RuleConfigParserFactoryMap { //工厂的工厂
    private static final Map<String, IRuleConfigParserFactory> cachedFactories = new Map<String, IRuleConfigParserFactory> ();
    static {
        cachedFactories.put("json", new JsonRuleConfigParserFactory());
        cachedFactories.put("xml", new XmlRuleConfigParserFactory());
        cachedFactories.put("yaml", new YamlRuleConfigParserFactory());
        cachedFactories.put("properties", new PropertiesRuleConfigParserFactory())
    }
    
    public static IRuleConfigParserFactory getParserFactory(String type) {
        if (type == null || type.isEmpty()) {
        	return null;
        }
        IRuleConfigParserFactory parserFactory = cachedFactories.get(type.toLowerCase());
        return parserFactory;
    }
}
```

当对象的创建逻辑比较复杂，不只是简单的 new 一下就可以，而是要 组合其他类对象，做各种初始化操作的时候，我们推荐使用工厂方法模式，将复杂的创建逻 辑拆分到多个工厂类中，让每个工厂类都不至于过于复杂。而使用简单工厂模式，将所有的 创建逻辑都放到一个工厂类中，会导致这个工厂类变得很复杂。 除此之外，在某些场景下，如果对象不可复用，那工厂类每次都要返回不同的对象。如果我 们使用简单工厂模式来实现，就只能选择第一种包含 if 分支逻辑的实现方式。如果我们还 想避免烦人的 if-else 分支逻辑，这个时候，我们就推荐使用工厂方法模式。

##### 抽象工厂（Abstract Factory）

在简单工厂和工厂方法中，类只有一种分类方式。比如，在规则配置解析那个例子中，解析器类只会根据配置文件格式（Json、Xml、Yaml……）来分类。但是，如果类有两种分类方式，比如，我们既可以按照配置文件格式来分类，也可以按照解析的对象（Rule 规则配置 还是 System 系统配置）来分类，那就会有 8 个 parser 类。

```java
public interface IConfigParserFactory {
    IRuleConfigParser createRuleParser();
    ISystemConfigParser createSystemParser();
    //此处可以扩展新的parser类型，比如IBizConfigParser
}

public class JsonConfigParserFactory implements IConfigParserFactory {
    @Override
    public IRuleConfigParser createRuleParser() {
    	return new JsonRuleConfigParser();
    }
    
    @Override
    public ISystemConfigParser createSystemParser() {
    	return new JsonSystemConfigParser();
    }
}

public class XmlConfigParserFactory implements IConfigParserFactory {
    @Override
    public IRuleConfigParser createRuleParser() {
    	return new XmlRuleConfigParser();
	}
    
    @Override
    public ISystemConfigParser createSystemParser() {
    	return new XmlSystemConfigParser();
    }
}
```

##### 工厂模式作用

- 封装变化：创建逻辑有可能变化，封装成工厂类之后，创建逻辑的变更对调用者透明。
- 代码复用：创建代码抽离到独立的工厂类之后可以复用。 
- 隔离复杂性：封装复杂的创建逻辑，调用者无需了解如何创建对象。 
- 控制复杂度：将创建代码抽离出来，让原本的函数或类职责更单一，代码更简洁。

##### 工厂模式使用总结

当创建逻辑比较复杂，是一个“大工程”的时候，我们就考虑使用工厂模式，封装对象的创 建过程，将对象的创建和使用相分离。何为创建逻辑比较复杂呢？我总结了下面两种情况。

- 第一种情况：类似规则配置解析的例子，代码中存在 if-else 分支判断，动态地根据不同 的类型创建不同的对象。针对这种情况，我们就考虑使用工厂模式，将这一大坨 if-else 创建对象的代码抽离出来，放到工厂类中。
- 第二种情况，尽管我们不需要根据不同的类型创建不同的对象，但是，单个对象本身 的创建过程比较复杂，比如前面提到的要组合其他类对象，做各种初始化操作。在这种 情况下，我们也可以考虑使用工厂模式，将对象的创建过程封装到工厂类中。

对于第一种情况，当每个对象的创建逻辑都比较简单的时候，我推荐使用简单工厂模式，将 多个对象的创建逻辑放到一个工厂类中。当每个对象的创建逻辑都比较复杂的时候，为了避 免设计一个过于庞大的简单工厂类，我推荐使用工厂方法模式，将创建逻辑拆分得更细，每 个对象的创建逻辑独立到各自的工厂类中。同理，对于第二种情况，因为单个对象本身的创 建逻辑就比较复杂，所以，我建议使用工厂方法模式。

如果创建对象的逻辑并不复杂，那我们就直接通过 new 来创建对象就可以了，不需要使用工厂模式。

#### 3. 建造者模式

我们需要定义一个资源池配置类 ResourcePoolConfig。这里的资源池，你可以简单理解为线程池、连接池、对象池等。在这个资源池配置类中，有以下几个成员变量，也就是可配置项。现在，请你编写代码实现这个 ResourcePoolConfig 类。

可以直接使用构造函数。如果参数过多，构造函数里传入必填参数，其他的用set方法。如果必填参数过多，用建造者模式。

```java
public class ResourcePoolConfig {
    private String name;
    private int maxTotal;
    private int maxIdle;
    private int minIdle;
    	
    private ResourcePoolConfig(Builder builder) {
        this.name = builder.name;
        this.maxTotal = builder.maxTotal;
        this.maxIdle = builder.maxIdle;
        this.minIdle = builder.minIdle;
    }
    //...省略getter方法...
    //我们将Builder类设计成了ResourcePoolConfig的内部类。
    //我们也可以将Builder类设计成独立的非内部类ResourcePoolConfigBuilder。
    public static class Builder {
        private static final int DEFAULT_MAX_TOTAL = 8;
        private static final int DEFAULT_MAX_IDLE = 8;
        private static final int DEFAULT_MIN_IDLE = 0;

        private String name;
        private int maxTotal = DEFAULT_MAX_TOTAL;
        private int maxIdle = DEFAULT_MAX_IDLE;
        private int minIdle = DEFAULT_MIN_IDLE;

        public ResourcePoolConfig build() {
            // 校验逻辑放到这里来做，包括必填项校验、依赖关系校验、约束条件校验等
            if (StringUtils.isBlank(name)) {
                    throw new IllegalArgumentException("...");
            }
            if (maxIdle > maxTotal) {
                throw new IllegalArgumentException("...");
            }
            if (minIdle > maxTotal || minIdle > maxIdle) {
                throw new IllegalArgumentException("...");
            }
            return new ResourcePoolConfig(this);
        }
        
        public Builder setName(String name) {
            if (StringUtils.isBlank(name)) {
            	throw new IllegalArgumentException("...");
            }
            this.name = name;
            return this;
        }
        
        public Builder setMaxTotal(int maxTotal) {
            if (maxTotal <= 0) {
            	throw new IllegalArgumentException("...");
            }
            this.maxTotal = maxTotal;
            return this;
        }
        
        public Builder setMaxIdle(int maxIdle) {
            if (maxIdle < 0) {
            	throw new IllegalArgumentException("...");
            }
            this.maxIdle = maxIdle;
            return this;
        }
        
        public Builder setMinIdle(int minIdle) {
            if (minIdle < 0) {
            	throw new IllegalArgumentException("...");
            }
            this.minIdle = minIdle;
            return this;
        }
    }
}

// 这段代码会抛出IllegalArgumentException，因为minIdle>maxIdle
ResourcePoolConfig config = new ResourcePoolConfig.Builder()
.setName("dbconnectionpool")
.setMaxTotal(16)
.setMaxIdle(10)
.setMinIdle(12)
.build();
```

#### 4. 原型模式

##### 原理和应用

如果对象的创建成本比较大，而同一个类的不同对象之间差别不大（大部分字段都相同），在这种情况下，我们可以利用对已有对象（原型）进行复制（或者叫拷贝）的方式来创建新对象，以达到节省创建时间的目的。这种基于原型来创建对象的方式就叫作原型设计模式（Prototype Design Pattern），简称原型模式。

##### 何为创建成本大

实际上，创建对象包含的申请内存、给成员变量赋值这一过程，本身并不会花费太多时间， 或者说对于大部分业务系统来说，这点时间完全是可以忽略的。应用一个复杂的模式，只得 到一点点的性能提升，这就是所谓的过度设计，得不偿失。 但是，如果对象中的数据需要经过复杂的计算才能得到（比如排序、计算哈希值），或者需 要从 RPC、网络、数据库、文件系统等非常慢速的 IO 中读取，这种情况下，我们就可以利 用原型模式，从其他已有对象中直接拷贝得到，而不用每次在创建新对象的时候，都重复执 行这些耗时的操作。

##### 原型模式的实现方式：深拷贝和浅拷贝

浅拷贝和深拷贝的区别在于，浅拷贝只会复制图中的索引（散列表），不会复制数据（SearchWord 对象）本身。相反，深拷贝不仅仅会复制索引，还会复制数据本身。浅拷贝得到的对象（newKeywords）跟原始对象（currentKeywords）共享数据（SearchWord 对象），而深拷贝得到的是一份完完全全独立的对象。

##### 深拷贝的实现

###### 第一种: 递归

递归拷贝对象、对象的引用对象以及引用对象的引用对象……直到要拷贝的对 象只包含基本数据类型数据，没有引用对象为止。

```java
public class Demo {
    private HashMap<String, SearchWord> currentKeywords=new HashMap<>();
    private long lastUpdateTime = -1;
    
    public void refresh() {
        // Deep copy
        HashMap<String, SearchWord> newKeywords = new HashMap<>();
        for (HashMap.Entry<String, SearchWord> e : currentKeywords.entrySet()) {
            SearchWord searchWord = e.getValue();
            SearchWord newSearchWord = new SearchWord(
            searchWord.getKeyword(), searchWord.getCount(), searchWord.getLas
            newKeywords.put(e.getKey(), newSearchWord);
    	}
                
        // 从数据库中取出更新时间>lastUpdateTime的数据，放入到newKeywords中
        List<SearchWord> toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);
        long maxNewUpdatedTime = lastUpdateTime;
        for (SearchWord searchWord : toBeUpdatedSearchWords) {
            if (searchWord.getLastUpdateTime() > maxNewUpdatedTime) {
                maxNewUpdatedTime = searchWord.getLastUpdateTime();
            }
            if (newKeywords.containsKey(searchWord.getKeyword())) {
                SearchWord oldSearchWord = newKeywords.get(searchWord.getKeyword());
                oldSearchWord.setCount(searchWord.getCount());
                oldSearchWord.setLastUpdateTime(searchWord.getLastUpdateTime());
            } else {
                newKeywords.put(searchWord.getKeyword(), searchWord);
            }
        }
                
        lastUpdateTime = maxNewUpdatedTime;
        currentKeywords = newKeywords;
    }
            
    private List<SearchWord> getSearchWords(long lastUpdateTime) {
        // TODO: 从数据库中取出更新时间>lastUpdateTime的数据
        return null;
    }
}
```

###### 第二种方法：先将对象序列化，然后再反序列化成新的对象。

```java
public Object deepCopy(Object object) {
    ByteArrayOutputStream bo = new ByteArrayOutputStream();
    ObjectOutputStream oo = new ObjectOutputStream(bo);
    oo.writeObject(object);
    ByteArrayInputStream bi = new ByteArrayInputStream(bo.toByteArray());
    ObjectInputStream oi = new ObjectInputStream(bi);
    return oi.readObject();
}
```

##### 浅拷贝和深拷贝结合的方法, 更快, 更省空间

先用浅拷贝, 需要更新的就用深拷贝创建新的对象, 替换原来的老对象.

```java
public class Demo {
    private HashMap<String, SearchWord> currentKeywords=new HashMap<>();
    private long lastUpdateTime = -1;
    
    public void refresh() {
        // Shallow copy
        HashMap<String, SearchWord> newKeywords = (HashMap<String, SearchWord>) currentKeywords.clone();
        // 从数据库中取出更新时间>lastUpdateTime的数据，放入到newKeywords中
        List<SearchWord> toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);
        long maxNewUpdatedTime = lastUpdateTime;
        for (SearchWord searchWord : toBeUpdatedSearchWords) {
            if (searchWord.getLastUpdateTime() > maxNewUpdatedTime) {
            	maxNewUpdatedTime = searchWord.getLastUpdateTime();
            }
            if (newKeywords.containsKey(searchWord.getKeyword())) {
            	newKeywords.remove(searchWord.getKeyword());
            }
            newKeywords.put(searchWord.getKeyword(), searchWord);
        }
        lastUpdateTime = maxNewUpdatedTime;
        currentKeywords = newKeywords;
    }
    
    private List<SearchWord> getSearchWords(long lastUpdateTime) {
        // TODO: 从数据库中取出更新时间>lastUpdateTime的数据
        return null;
    }
}
```

### 结构型模式

#### 5. 代理模式

它在不改变原始类 （或叫被代理类）代码的情况下，通过引入代理类来给原始类附加功能。例如我想在UserController这个类里面的方法都加入一个计时功能，那么就需要在原本逻辑的前后都要写一点代码，如下所示。

```java
public class UserController {
    //...省略其他属性和方法...
    private MetricsCollector metricsCollector; // 依赖注入
    
    public UserVo login(String telephone, String password) {
        long startTimestamp = System.currentTimeMillis();
        // ... 省略login逻辑...
        long endTimeStamp = System.currentTimeMillis();
        long responseTime = endTimeStamp - startTimestamp;
        RequestInfo requestInfo = new RequestInfo("login", responseTime, startTimestamp);
        metricsCollector.recordRequest(requestInfo);
        //...返回UserVo数据...
    }
                                                  
    public UserVo register(String telephone, String password) {
        long startTimestamp = System.currentTimeMillis();
        // ... 省略register逻辑...
        long endTimeStamp = System.currentTimeMillis();
        long responseTime = endTimeStamp - startTimestamp;
        RequestInfo requestInfo = new RequestInfo("register", responseTime, startTimestamp);
        metricsCollector.recordRequest(requestInfo);
        //...返回UserVo数据...
    }
}
```

上面的写法有两个问题

1. 性能计数器框架代码侵入到业务代码中，跟业务码高度耦合。如果未来需要替换这个框架，那替换的成本会比较大。
2. 收集接口请求的代码跟业务代码无关，本就不应该放到一个类中。业务类最好职责更加单一，只聚焦业务处理。

为了将框架代码和业务代码解耦，代理模式就派上用场了。代理类UserControllerProxy 和原始类 UserController 实现相同的接口 IUserController。UserController 类只负责业务功能。代理类 UserControllerProxy 负责在业务代码执行前后附加其他逻辑代码，并通 过委托的方式调用原始类来执行业务代码。

```java
public interface IUserController {
    UserVo login(String telephone, String password);
    UserVo register(String telephone, String password);
}

public class UserController implements IUserController {
    //...省略其他属性和方法...
    @Override
    public UserVo login(String telephone, String password) {
        //...省略login逻辑...
        //...返回UserVo数据...
    }

    @Override
    public UserVo register(String telephone, String password) {
        //...省略register逻辑...
        //...返回UserVo数据...
    }
}

public class UserControllerProxy implements IUserController {
    private MetricsCollector metricsCollector;
    private UserController userController;
    
    public UserControllerProxy(UserController userController) {
        this.userController = userController;
        this.metricsCollector = new MetricsCollector();
    }
    
    @Override
    public UserVo login(String telephone, String password) {
        long startTimestamp = System.currentTimeMillis();
        // 委托
        UserVo userVo = userController.login(telephone, password);
        long endTimeStamp = System.currentTimeMillis();
        long responseTime = endTimeStamp - startTimestamp;
        RequestInfo requestInfo = new RequestInfo("login", responseTime, startTimestamp);
        metricsCollector.recordRequest(requestInfo);
        return userVo;
    }
    @Override
    public UserVo register(String telephone, String password) {
        long startTimestamp = System.currentTimeMillis();
        UserVo userVo = userController.register(telephone, password);
        long endTimeStamp = System.currentTimeMillis();
        long responseTime = endTimeStamp - startTimestamp;
        RequestInfo requestInfo = new RequestInfo("register", responseTime, startTimestamp);
        metricsCollector.recordRequest(requestInfo);
        return userVo;
    }
}
                                                  
//UserControllerProxy使用举例
//因为原始类和代理类实现相同的接口，是基于接口而非实现编程
//将UserController类对象替换为UserControllerProxy类对象，不需要改动太多代码
IUserController userController = new UserControllerProxy(new UserController())
```

以上解决方法需要被代理类是自己写的类，这样可以改动它，让它和代理类都实现同一个接口。但如果是第三方库包里面的类，我们一般都是采用继承的方式。

```java
public class UserControllerProxy extends UserController {
    private MetricsCollector metricsCollector;
    
    public UserControllerProxy() {
    	this.metricsCollector = new MetricsCollector();
    }
    
    public UserVo login(String telephone, String password) {
        long startTimestamp = System.currentTimeMillis();
        UserVo userVo = super.login(telephone, password);
        long endTimeStamp = System.currentTimeMillis();
        long responseTime = endTimeStamp - startTimestamp;
        RequestInfo requestInfo = new RequestInfo("login", responseTime, startTimes
        metricsCollector.recordRequest(requestInfo);
        return userVo;
    }
                                                  
    public UserVo register(String telephone, String password) {
        long startTimestamp = System.currentTimeMillis();
        UserVo userVo = super.register(telephone, password);
        long endTimeStamp = System.currentTimeMillis();
        long responseTime = endTimeStamp - startTimestamp;
        RequestInfo requestInfo = new RequestInfo("register", responseTime, startTimestamp);
        metricsCollector.recordRequest(requestInfo);
        return userVo;
    }
}
                                          
//UserControllerProxy使用举例
UserController userController = new UserControllerProxy();
```

不过，刚刚的代码实现还是有点问题。一方面，我们需要在代理类中，将原始类中的所有的方法，都重新实现一遍，并且为每个方法都附加相似的代码逻辑。另一方面，如果要添加的附加功能的类有不止一个，我们需要针对每个类都创建一个代理类。 如果有 50 个要添加附加功能的原始类，那我们就要创建 50 个对应的代理类。这会导致项目中类的个数成倍增加，增加了代码维护成本。那么可以使用动态代理。

```java
public class UserControllerProxy {
    private UserController userController;
    public UserControllerProxy() {
        this.userController = new UserController();
    }
    public Object createProxy(Object proxiedObject) {
        Class<?>[] interfaces = proxiedObject.getClass().getInterfaces();
        DynamicProxyHandler handler = new DynamicProxyHandler(proxiedObject);
        return Proxy.newProxyInstance(proxiedObject.getClass().getClassLoader(), interfaces, handler);
    }

    private class DynamicProxyHandler implements InvocationHandler {
        private Object proxiedObject;
        public DynamicProxyHandler(Object proxiedObject) {
            this.proxiedObject = proxiedObject;
        }
        @Override
        public Object invoke(Object proxy, Method method, Object[] args) throws InvocationTargetException, IllegalAccessException {
            long startTimestamp = System.currentTimeMillis();
            Object result = method.invoke(proxiedObject, args);
            long endTimeStamp = System.currentTimeMillis();
            long responseTime = endTimeStamp - startTimestamp;
            MainTest.map.put(method.getName(), responseTime);
            return result;
        }
    }
}

public interface IUserController {
    void login(String username);

    String register();
}

public class UserController implements IUserController{
    @Override
    public void login(String username) {
        System.out.println("UserController：执行登录方法！");
        System.out.println("用户名：" + username);
    }

    @Override
    public String register() {
        System.out.println("UserController：执行注册方法！");
        return "注册成功";
    }
}

// 使用举例
public class MainTest {
    public static Map<String, Object> map = new HashMap<>();
    public static void main(String[] args) {
        UserControllerProxy userControllerProxy = new UserControllerProxy();
        IUserController userController = (IUserController) userControllerProxy.createProxy(new UserController());
        userController.login("lyl");
        String result = userController.register();
        System.out.println(result);

        System.out.println(map);
    }
}
```

代理模式的应用场景

- 业务系统的非功能性需求开发
  - 比如监控、 统计、鉴权、限流、事务、幂等、日志
  - 这部分工作可以用Spring AOP来解决。Spring AOP 底层的实现原理就是基于动态代理。
- 代理模式在 RPC中的应用
  - RPC 框架也可以看作一种代理模式，GoF 的《设计模式》一书中把它称作远程代理。通过远程代理，将网络通信、数据编解码等细节隐藏起来。客户端在使用 RPC 服务的时候，就像使用本地函数一样，无需了解跟服务器交互的细节。
- 代理模式在缓存中的应用
  - 比如查询某个信息，可以开发两个接口，一个支持缓存，一个支持实时查询，但这样增加开发成本。如果是基于 Spring 框架来开发的话，那就可以在 AOP 切面中完成接口缓存的功能。在应用启动的时 候，我们从配置文件中加载需要支持缓存的接口，以及相应的缓存策略（比如过期时间） 等。当请求到来的时候，我们在 AOP 切面中拦截请求，如果请求中带有支持缓存的字段 （比如 http://…?..&cached=true），我们便从缓存（内存缓存或者 Redis 缓存等）中获 取数据直接返回。

#### 6. 桥接模式

将抽象和实现解耦，让它们可以独立变化。

JDBC就使用了桥接模式。

举例

```java
public enum NotificationEmergencyLevel {
    SEVERE,
    URGENCY,
    NORMAL,
    TRIVIAL
}

public class Notification {
    private List<String> emailAddresses;
    private List<String> telephones;
    private List<String> wechatIds;
    
    public Notification() {}
    
    public void setEmailAddress(List<String> emailAddress) {
    	this.emailAddresses = emailAddress;
    }
    
    public void setTelephones(List<String> telephones) {
   		this.telephones = telephones;
    }
    
    public void setWechatIds(List<String> wechatIds) {
    	this.wechatIds = wechatIds;
    }
    
    public void notify(NotificationEmergencyLevel level, String message) {
        if (level.equals(NotificationEmergencyLevel.SEVERE)) {
        	//...自动语音电话
        } else if (level.equals(NotificationEmergencyLevel.URGENCY)) {
        	//...发微信
        } else if (level.equals(NotificationEmergencyLevel.NORMAL)) {
        	//...发邮件
        } else if (level.equals(NotificationEmergencyLevel.TRIVIAL)) {
        	//...发邮件
        }
    }
}

//在API监控告警的例子中，我们如下方式来使用Notification类：
public class ErrorAlertHandler extends AlertHandler {
    public ErrorAlertHandler(AlertRule rule, Notification notification){
    	super(rule, notification);
    }
    
    @Override
    public void check(ApiStatInfo apiStatInfo) {
        if (apiStatInfo.getErrorCount() > rule.getMatchedRule(apiStatInfo.getApi()) {
            notification.notify(NotificationEmergencyLevel.SEVERE, "...");
        }
    }
}
```

Notification 类的代码实现有一个最明显的问题，那就是有很多 if-else 分支逻辑。实际上，如果每个分支中的代码都不复杂，后期也没有无限膨胀的可能（增加更多 if-else 分支判断），那这样的设计问题并不大，没必要非得一定要摒弃 if-else 分支逻辑。不过，Notification 的代码显然不符合这个条件。因为每个 if-else 分支中的代码逻辑都比较复杂，发送通知的所有逻辑都扎堆在 Notification 类中。

针对 Notification 的代码，我们将不同渠道的发送逻辑剥离出来，形成独立的消息发送类 （MsgSender 相关类）。其中，Notification 类相当于抽象，MsgSender 类相当于实 现，两者可以独立开发，通过组合关系（也就是桥梁）任意组合在一起。所谓任意组合的意 思就是，不同紧急程度的消息和发送渠道之间的对应关系，不是在代码中固定写死的，我们 可以动态地去指定（比如，通过读取配置来获取对应关系）。

```java
public interface MsgSender {
	void send(String message);
}

public class TelephoneMsgSender implements MsgSender {
    private List<String> telephones;
    
    public TelephoneMsgSender(List<String> telephones) {
    	this.telephones = telephones;
    }
    
    @Override
    public void send(String message) {
    	//...
    }
}

public class EmailMsgSender implements MsgSender {
	// 与TelephoneMsgSender代码结构类似，所以省略...
}

public class WechatMsgSender implements MsgSender {
	// 与TelephoneMsgSender代码结构类似，所以省略...
}

public abstract class Notification {
    protected MsgSender msgSender;
    
    public Notification(MsgSender msgSender) {
    	this.msgSender = msgSender;
    }
    
    public abstract void notify(String message);
}

public class SevereNotification extends Notification {
    public SevereNotification(MsgSender msgSender) {
    	super(msgSender);
    }
    
    @Override
    public void notify(String message) {
    	msgSender.send(message);
    }
}

public class UrgencyNotification extends Notification {
	// 与SevereNotification代码结构类似，所以省略...
}

public class NormalNotification extends Notification {
	// 与SevereNotification代码结构类似，所以省略...
}

public class TrivialNotification extends Notification {
	// 与SevereNotification代码结构类似，所以省略...
}
```

#### 7. 装饰器模式

Java IO就使用了装饰器模式。就是运用“使用组合替代继承”的思想。以下是Java IO的部分源码。

```java
public abstract class InputStream {
    //...
    public int read(byte b[]) throws IOException {
    	return read(b, 0, b.length);
    }
    
    public int read(byte b[], int off, int len) throws IOException {
    	//...
    }
    
    public long skip(long n) throws IOException {
    	//...
    }
    
    public int available() throws IOException {
    	return 0;
    }
    
    public void close() throws IOException {}
    
    public synchronized void mark(int readlimit) {}
    
    public synchronized void reset() throws IOException {
    	throw new IOException("mark/reset not supported");
    }
    
    public boolean markSupported() {
    	return false;
    }
}

public class BufferedInputStream extends InputStream {
    protected volatile InputStream in;
    
    protected BufferedInputStream(InputStream in) {
    	this.in = in;
    }
    
    //...实现基于缓存的读数据接口...
}

public class DataInputStream extends InputStream {
    protected volatile InputStream in;
    
    protected DataInputStream(InputStream in) {
    	this.in = in;
    }
    
    //...实现读取基本类型数据的接口
}
```

看了上面的代码，你可能会问，那装饰器模式就是简单的“用组合替代继承”吗？当然不是。从 Java IO 的设计来看，装饰器模式相对于简单的组合关系，还有两个比较特殊的地方。

- 第一个比较特殊的地方是：装饰器类和原始类继承同样的父类，这样我们可以对原始类“嵌套”多个装饰器类。比如，下面这样一段代码，我们对 FileInputStream 嵌套了两个装饰器类：BufferedInputStream 和DataInputStream，让它既支持缓存读取，又支持按照基本数据类型来读取数据。

  ```java
  InputStream in = new FileInputStream("/user/wangzheng/test.txt");
  InputStream bin = new BufferedInputStream(in);
  DataInputStream din = new DataInputStream(bin);
  int data = din.readInt();
  ```

- 第二个比较特殊的地方是：装饰器类是对功能的增强，这也是装饰器模式应用场景的一个重要特点。实际上，符合“组合关系”这种代码结构的设计模式有很多，比如之前讲过的代理模式、桥接模式，还有现在的装饰器模式。尽管它们的代码结构很相似，但是每种设计模式的意图是不同的。就拿比较相似的代理模式和装饰器模式来说吧，代理模式中，代理类附加的是跟原始类无关的功能，而在装饰器模式中，装饰器类附加的是跟原始类相关的增强功能。

  ```java
  // 代理模式的代码结构(下面的接口也可以替换成抽象类)
  public interface IA {
  	void f();
  }
  
  public class A impelements IA {
  	public void f() { //... }
  }
  
  public class AProxy impelements IA {
      private IA a;
      
      public AProxy(IA a) {
      	this.a = a;
  	}
  	
      public void f() {
          // 新添加的代理逻辑
          a.f();
          // 新添加的代理逻辑
      }
  }
  
  // 装饰器模式的代码结构(下面的接口也可以替换成抽象类)
  public interface IA {
  	void f();
  }
  
  public class A impelements IA {
  	public void f() { //... }
  }
  
  public class ADecorator impelements IA {
      private IA a;
      
      public ADecorator(IA a) {
      	this.a = a;
      }
      
      public void f() {
          // 功能增强代码
          a.f();
          // 功能增强代码
      }
  }
  ```

实际上，如果去查看 JDK 的源码，你会发现，BufferedInputStream、DataInputStream 并非继承自 InputStream，而是另外一个叫FilterInputStream 的类。那这又是出于什么 样的设计意图，才引入这样一个类呢？

我们再重新来看一下 BufferedInputStream 类的代码。InputStream 是一个抽象类而非接口，而且它的大部分函数（比如 read()、available()）都有默认实现，按理来说，我们只需要在 BufferedInputStream 类中重新实现那些需要增加缓存功能的函数就可以了，其他函数继承 InputStream 的默认实现。但实际上，这样做是行不通的。

对于即便是不需要增加缓存功能的函数来说，BufferedInputStream 还是必须把它重新实现一遍，简单包裹对 InputStream 对象的函数调用。具体的代码示例如下所示。如果不重新实现，那 BufferedInputStream 类就无法将最终读取数据的任务，委托给传递进来的 InputStream 对象来完成。

```java
public class BufferedInputStream extends InputStream {
    protected volatile InputStream in;
    
    protected BufferedInputStream(InputStream in) {
    	this.in = in;
    }
    
    // f()函数不需要增强，只是重新调用一下InputStream in对象的f()
    public void f() {
    	in.f();
    }
}
```

实际上，DataInputStream 也存在跟 BufferedInputStream 同样的问题。为了避免代码重复，Java IO 抽象出了一个装饰器父类 FilterInputStream，代码实现如下所示。InputStream 的所有的装饰器类（BufferedInputStream、DataInputStream）都继承自这个装饰器父类。这样，装饰器类只需要实现它需要增强的方法就可以了，其他方法继承装饰器父类的默认实现。

```java
public class FilterInputStream extends InputStream {
    protected volatile InputStream in;
    
    protected FilterInputStream(InputStream in) {
    	this.in = in;
    }
    
    public int read() throws IOException {
    	return in.read();
    }
    
    public int read(byte b[]) throws IOException {
    	return read(b, 0, b.length);
    }
    
    public int read(byte b[], int off, int len) throws IOException {
    	return in.read(b, off, len);
    }
    
    public long skip(long n) throws IOException {
    	return in.skip(n);
    }
    
    public int available() throws IOException {
    	return in.available();
    }
    
    public void close() throws IOException {
    	in.close();
    }
    
    public synchronized void mark(int readlimit) {
    	in.mark(readlimit);
    }
    
    public synchronized void reset() throws IOException {
    	in.reset();
    }
    
    public boolean markSupported() {
    	return in.markSupported();
    }
}

```

装饰器模式主要解决继承关系过于复杂的问题，通过组合来替代继承。它主要的作用是给原 始类添加增强功能。这也是判断是否该用装饰器模式的一个重要的依据。除此之外，装饰器 模式还有一个特点，那就是可以对原始类嵌套使用多个装饰器。为了满足这个应用场景，在 设计的时候，装饰器类需要跟原始类继承相同的抽象类或者接口。

#### 8. 适配器模式

适配器模式的英文翻译是 Adapter Design Pattern。顾名思义，这个模式就是用来做适配的，它将不兼容的接口转换为可兼容的接口，让原本由于接口不兼容而不能一起工作的类可以一起工作。

适配器模式有两种实现方式：

- 类适配器 -- 继承

  ```java
  // 类适配器: 基于继承
  public interface ITarget {
      void f1();
      
      void f2();
      
      void fc();
  }
  
  public class Adaptee {
      public void fa() {
          //...
      }
      
      public void fb() {
          //...
      }
      
      public void fc() {
          //...
      }
  }
          
  public class Adaptor extends Adaptee implements ITarget {
      public void f1() {
      	super.fa();
      }
      
      public void f2() {
      	//...重新实现f2()...
      }
      
      // 这里fc()不需要实现，直接继承自Adaptee，这是跟对象适配器最大的不同点
  }
  ```

  

- 对象适配器 -- 组合

  ```java
  // 对象适配器：基于组合
  public interface ITarget {
      void f1();
      
      void f2();
      
      void fc();
  }
  
  public class Adaptee {
      public void fa() {
          //...
      }
      
      public void fb() {
          //...
      }
      
      public void fc() {
          //...
      }
  }
  
  public class Adaptor implements ITarget {
      private Adaptee adaptee;
      
      public Adaptor(Adaptee adaptee) {
      	this.adaptee = adaptee;
      }
      
      public void f1() {
      	adaptee.fa(); //委托给Adaptee
      }
      
      public void f2() {
      	//...重新实现f2()...
      }
      
      public void fc() {
      	adaptee.fc();
      }
  }
  ```

  

在实际开发中，如何考虑使用哪一种？

- 如果 Adaptee 接口并不多，那两种实现方式都可以
- 如果 Adaptee 接口很多，而且 Adaptee 和 ITarget 接口定义大部分都相同，那推荐使用类适配器，因为 Adaptor 复用父类 Adaptee 的接口，比起对象适配器的实现方式，Adaptor 的代码量要少一些
- 如果 Adaptee 接口很多，而且 Adaptee 和 ITarget 接口定义大部分都不相同，那推荐使用对象适配器，因为组合结构相对于继承更加灵活。

什么时候会用到适配器模式呢?

适配器模式可以看作一种“补偿模式”，用来补救设计上的缺陷。如果在设计初期，我们就能协调规避接口不兼容的问题，那这种模式就没有应用的机会了。

- 封装有缺陷的接口设计

  引入的第三方包有缺陷，需要进行二次封装，抽象出更好的接口设计

  ```java
  public class CD { //这个类来自外部sdk，我们无权修改它的代码
  	//...
      public static void staticFunction1() {
          //...
      }
      
      public void uglyNamingFunction2() {
          //...
      }
      
      public void tooManyParamsFunction3(int paramA, int paramB, ...) {
          //...
      }
      
      public void lowPerformanceFunction4() {
          //...
      }
  }
      
  // 使用适配器模式进行重构
  public class ITarget {
      void function1();
      
      void function2();
      
      void fucntion3(ParamsWrapperDefinition paramsWrapper);
      
      void function4();
      //...
  }
      
  // 注意：适配器类的命名不一定非得末尾带Adaptor
  public class CDAdaptor extends CD implements ITarget {
      //...
      public void function1() {
      	super.staticFunction1();
      }
      
      public void function2() {
      	super.uglyNamingFucntion2();
      }
      
      public void function3(ParamsWrapperDefinition paramsWrapper) {
      	super.tooManyParamsFunction3(paramsWrapper.getParamA(), ...);
      }
      
      public void function4() {
      	//...reimplement it...
      }
  }
  ```

- 统一多个类的接口设计

  某个功能的实现依赖多个外部系统（或者说类）。通过适配器模式，将它们的接口适配为统一的接口定义，然后我们就可以使用多态的特性来复用代码逻辑。

  假设我们的系统要对用户输入的文本内容做敏感词过滤，为了提高过滤的召回率，我们引入了多款第三方敏感词过滤系统，依次对用户输入的内容进行过滤，过滤掉尽可能多的敏感词。但是，每个系统提供的过滤接口都是不同的。这就意味着我们没法复用一套逻辑来调用各个系统。这个时候，我们就可以使用适配器模式，将所有系统的接口适配为统一的接口定义，这样我们可以复用调用敏感词过滤的代码。

  ```java
  public class ASensitiveWordsFilter { // A敏感词过滤系统提供的接口
      //text是原始文本，函数输出用***替换敏感词之后的文本
      public String filterSexyWords(String text) {
      	// ...
      }
      
      public String filterPoliticalWords(String text) {
      	// ...
      }
  }
  
  public class BSensitiveWordsFilter { // B敏感词过滤系统提供的接口
      public String filter(String text) {
      	//...
      }
  }
  
  public class CSensitiveWordsFilter { // C敏感词过滤系统提供的接口
      public String filter(String text, String mask) {
      	//...
      }
  }
  
  // 未使用适配器模式之前的代码：代码的可测试性、扩展性不好
  public class RiskManagement {
      private ASensitiveWordsFilter aFilter = new ASensitiveWordsFilter();
      private BSensitiveWordsFilter bFilter = new BSensitiveWordsFilter();
      private CSensitiveWordsFilter cFilter = new CSensitiveWordsFilter();
      
      public String filterSensitiveWords(String text) {
          String maskedText = aFilter.filterSexyWords(text);
          maskedText = aFilter.filterPoliticalWords(maskedText);
          maskedText = bFilter.filter(maskedText);
          maskedText = cFilter.filter(maskedText, "***");
          return maskedText;
      }
  }
  
  // 使用适配器模式进行改造
  public interface ISensitiveWordsFilter { // 统一接口定义
  	String filter(String text);
  }
  
  public class ASensitiveWordsFilterAdaptor implements ISensitiveWordsFilter {
      private ASensitiveWordsFilter aFilter;
      
      public String filter(String text) {
          String maskedText = aFilter.filterSexyWords(text);
          maskedText = aFilter.filterPoliticalWords(maskedText);
          return maskedText;
      }
  }
  
  //...省略BSensitiveWordsFilterAdaptor、CSensitiveWordsFilterAdaptor...
  
  // 扩展性更好，更加符合开闭原则，如果添加一个新的敏感词过滤系统，
  
  // 这个类完全不需要改动；而且基于接口而非实现编程，代码的可测试性更好。
  public class RiskManagement {
      private List<ISensitiveWordsFilter> filters = new ArrayList<>();
      
      public void addSensitiveWordsFilter(ISensitiveWordsFilter filter) {
      	filters.add(filter);
      }
      
      public String filterSensitiveWords(String text) {
          String maskedText = text;
          for (ISensitiveWordsFilter filter : filters) {
          	maskedText = filter.filter(maskedText);
          }
          return maskedText;
      }
  }
  ```

-  替换依赖的外部系统

  当我们把项目中依赖的一个外部系统替换为另一个外部系统的时候，利用适配器模式，可以减少对代码的改动。

  ```java
  // 外部系统A
  public interface IA {
      //...
      void fa();
  }
  
  public class A implements IA {
      //...
      public void fa() {
          //...
      }
  }
  
  // 在我们的项目中，外部系统A的使用示例
  public class Demo {
      private IA a;
      
      public Demo(IA a) {
      	this.a = a;
      }
      //...
  }
  
  Demo d = new Demo(new A());
  
  // 将外部系统A替换成外部系统B
  public class BAdaptor implements IA {
      private B b;
      
      public BAdaptor(B b) {
      	this.b= b;
      }
      
      public void fa() {
      	//...
      	b.fb();
      }
  }
  
  // 借助BAdaptor，Demo的代码中，调用IA接口的地方都无需改动，
  // 只需要将BAdaptor如下注入到Demo即可。
  Demo d = new Demo(new BAdaptor(new B()));
  ```

-  兼容老版本接口

  在做版本升级的时候，对于一些要废弃的接口，我们不直接将其删除，而是暂时保留，并且标注为 deprecated。JDK1.0 中包含一个遍历集合容器的类 Enumeration。JDK2.0 对这个类进行了重构，将它改名为 Iterator 类，并且对它的代码实现做了优化。但是考虑到如果将 Enumeration 直接从 JDK2.0 中删除，那使用 JDK1.0 的项目如果切换到 JDK2.0，代码就会编译不通过。为了避免这种情况的发生，我们必须把项目中所有使用到 Enumeration 的地方，都修改为使用 Iterator 才行。为了做到兼容使用低版本 JDK 的老代码，
  我们可以暂时保留 Enumeration 类，并将其实现替换为直接调用 Itertor。

  ```java
  public class Collections {
      public static Emueration emumeration(final Collection c) {
          return new Enumeration() {
              Iterator i = c.iterator();
  
              public boolean hasMoreElments() {
                  return i.hashNext();
              }
              
              public Object nextElement() {
              	return i.next();
              }
          }
      }
  }
  ```

- 适配不同格式的数据

  适配器模式主要用于接口的适配，实际上，它还可以用在不同格式的数据之
  间的适配。比如，把从不同征信系统拉取的不同格式的征信数据，统一为相同的格式，以方便存储和使用。再比如，Java 中的 Arrays.asList() 也可以看作一种数据适配器，将数组类型的数据转化为集合容器类型。

  ```java
  List<String> stooges = Arrays.asList("Larry", "Moe", "Curly");
  ```

剖析适配器模式在 Java 日志中的应用

比如，项目中用到的某个组件使用 log4j 来打印日志，而我们项目本身使用的是
logback。将组件引入到项目之后，我们的项目就相当于有了两套日志打印框架。每种日志框架都有自己特有的配置方式。所以，我们要针对每种日志框架编写不同的配置文件（比如，日志存储的文件地址、打印日志的格式）。如果引入多个组件，每个组件使用的日志框架都不一样，那日志本身的管理工作就变得非常复杂。所以，为了解决这个问题，我们需要统一日志打印框架。

如果你是做 Java 开发的，那 Slf4j 这个日志框架你肯定不陌生，它相当于 JDBC 规范，提供了一套打印日志的统一接口规范。不过，它只定义了接口，并没有提供具体的实现，需要配合其他日志框架（log4j、logback……）来使用。

不仅如此，Slf4j 的出现晚于 JUL、JCL、log4j 等日志框架，所以，这些日志框架也不可能牺牲掉版本兼容性，将接口改造成符合 Slf4j 接口规范。Slf4j 也事先考虑到了这个问题，所以，它不仅仅提供了统一的接口定义，还提供了针对不同日志框架的适配器。对不同日志框架的接口进行二次封装，适配成统一的 Slf4j 接口定义。

```java
// slf4j统一的接口定义
package org.slf4j;

public interface Logger {
    public boolean isTraceEnabled();
    
    public void trace(String msg);
    
    public void trace(String format, Object arg);
    
    public void trace(String format, Object arg1, Object arg2);
    
    public void trace(String format, Object[] argArray);
    
    public void trace(String msg, Throwable t);
    
    public boolean isDebugEnabled();
    
    public void debug(String msg);
    
    public void debug(String format, Object arg);
    
    public void debug(String format, Object arg1, Object arg2);
    
    public void debug(String format, Object[] argArray);
    
    public void debug(String msg, Throwable t);
    //...省略info、warn、error等一堆接口
}

// log4j日志框架的适配器
// Log4jLoggerAdapter实现了LocationAwareLogger接口，
// 其中LocationAwareLogger继承自Logger接口，
// 也就相当于Log4jLoggerAdapter实现了Logger接口。
package org.slf4j.impl;

public final class Log4jLoggerAdapter extends MarkerIgnoringBase
implements LocationAwareLogger, Serializable {
    final transient org.apache.log4j.Logger logger; // log4j
    
    public boolean isDebugEnabled() {
    	return logger.isDebugEnabled();
    }
    
    public void debug(String msg) {
    	logger.log(FQCN, Level.DEBUG, msg, null);
    }
    
    public void debug(String format, Object arg) {
        if (logger.isDebugEnabled()) {
            FormattingTuple ft = MessageFormatter.format(format, arg);
            logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());
        }
    }
    
    public void debug(String format, Object arg1, Object arg2) {
        if (logger.isDebugEnabled()) {
            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);
            logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());
        }
    }
    
    public void debug(String format, Object[] argArray) {
        if (logger.isDebugEnabled()) {
            FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);
            logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());
        }
    }
    
    public void debug(String msg, Throwable t) {
    	logger.log(FQCN, Level.DEBUG, msg, t);
    }
    //...省略一堆接口的实现...
}
```

#### 总结 -- 代理、桥接、装饰器、适配器 4 种设计模式的区别

- 代理模式：代理模式在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是控制访问，而非加强功能，这是它跟装饰器模式最大的不同。
- 桥接模式：桥接模式的目的是将接口部分和实现部分分离，从而让它们可以较为容易、也相对独立地加以改变。
- 装饰器模式：装饰者模式在不改变原始类接口的情况下，对原始类功能进行增强，并且支持多个装饰器的嵌套使用。
- 适配器模式：适配器模式是一种事后的补救策略。适配器提供跟原始类不同的接口，而代理模式、装饰器模式提供的都是跟原始类相同的接口。

#### 9. 门面模式

门面模式，也叫外观模式，英文全称是 Facade Design Pattern。Provide a unified interface to a set of interfaces in a subsystem. Facade Pattern
defines a higher-level interface that makes the subsystem easier to use.门面模式为子系统提供一组统一的接口，定义一组高层接口让子系统更易
用。

假设有一个系统 A，提供了 a、b、c、d 四个接口。系统 B 完成某个业务功能，需要调用A 系统的 a、b、d 接口。利用门面模式，我们提供一个包裹 a、b、d 接口调用的门面接口x，给系统 B 直接使用。

假设我们刚刚提到的系统 A 是一个后端服务器，系统 B 是 App 客户端。App 客户端通过后端服务器提供的接口来获取数据。我们知道，App 和服务器之间是通过移动网络通信的，网络通信耗时比较多，为了提高 App 的响应速度，我们要尽量减少 App 与服务器之间的网络通信次数。如果我们现在发现 App 客户端的响应速度比较慢，排查之后发现，是因为过多的接口调用过多的网络通信。针对这种情况，我们就可以利用门面模式，让后端服务器提供一个包裹a、b、d 三个接口调用的接口 x。App 客户端调用一次接口 x，来获取到所有想要的数据，将网络通信的次数从 3 次减少到 1 次，也就提高了 App 的响应速度。

门面模式的应用场景举例

1. 解决易用性问题

   门面模式可以用来封装系统的底层实现，隐藏系统的复杂性，提供一组更加简单易用、更高层的接口。比如，Linux 系统调用函数就可以看作一种“门面”。它是 Linux 操作系统暴露给开发者的一组“特殊”的编程接口，它封装了底层更基础的 Linux 内核调用。再比如，Linux 的 Shell 命令，实际上也可以看作一种门面模式的应用。它继续封装系统调用，提供更加友好、简单的命令，让我们可以直接通过执行命令来跟操作系统交互。

2. 解决性能问题

   上述例子中，通过将多个接口调用替换为一个门面接口调用，减少网络通信成本，提高 App 客户端的响应速度。

   如果门面接口不多，我们完全可以将它跟非门面接口放到一块，也不需要特殊标记，当作普
   通接口来用即可。如果门面接口很多，我们可以在已有的接口之上，再重新抽象出一层，专
   门放置门面接口，从类、包的命名上跟原来的接口层做区分。如果门面接口特别多，并且很
   多都是跨多个子系统的，我们可以将门面接口放到一个新的子系统中。

3. 解决分布式事务问题

   举例：在一个金融系统中，有两个业务领域模型，用户和钱包。假设有这样一个业务场景：在用户注册的时候，我们不仅会创建用户（在数据库 User 表中），还会给用户创建一个钱包（在数据库的 Wallet 表中）。假设有这样一个业务场景：在用户注册的时候，我们不仅会创建用户（在数据库 User 表中），还会给用户创建一个钱包（在数据库的 Wallet 表中）。但用户注册需要支持事务。要支持两个接口调用在一个事务中执行，是比较难实现的，这涉及分布式事务问题。虽然我们可以通过引入分布式事务框架或者事后补偿的机制来解决，但代码实现都比较复杂。而最简单的解决方案是，利用数据库事务或者 Spring 框架提供的事务（如果是 Java 语言的
   话），在一个事务中，执行创建用户和创建钱包这两个 SQL 操作。这就要求两个 SQL 操作要在一个接口中完成，所以，我们可以借鉴门面模式的思想，再设计一个包裹这两个操作的新接口，让新接口在一个事务中执行两个 SQL 操作。

#### 10. 组合模式

主要是用来处理树形结构数据。正因为其应用场景的特殊性，数据必须能表示成树形结构，这也导致了这种模式在实际的项目开发中并不那么常用。但是，一旦数据满足树形结构，应用这种模式就能发挥很大的作用，能让代码变得非常简洁。

将一组对象组织（Compose）成树形结构，以表示一种“部分 - 整 体”的层次结构。组合让客户端（在很多设计模式书籍中，“客户端”代指代码的使用者。）可以统一单个对象和组合对象的处理逻辑。

假设我们有这样一个需求：设计一个类来表示文件系统中的目录，能方便地实现下面这些功能：

- 动态地添加、删除某个目录下的子目录或文件；
- 统计指定目录下的文件个数；
- 统计指定目录下的文件总大小。

```java
public class FileSystemNode {
    private String path;
    
    private boolean isFile;
    
    private List<FileSystemNode> subNodes = new ArrayList<>();
    
    public FileSystemNode(String path, boolean isFile) {
        this.path = path;
        this.isFile = isFile;
    }
    
    public int countNumOfFiles() {
    	// TODO:...
    }
    
    public long countSizeOfFiles() {
    	// TODO:...
    }
    
    public String getPath() {
    	return path;
    }
    
    public void addSubNode(FileSystemNode fileOrDir) {
    	subNodes.add(fileOrDir);
    }
    
    public void removeSubNode(FileSystemNode fileOrDir) {
        int size = subNodes.size();
        int i = 0;
        for (; i < size; ++i) {
            if (subNodes.get(i).getPath().equalsIgnoreCase(fileOrDir.getPath())) {
            	break;
            }
        }
        if (i < size) {
            subNodes.remove(i);
        }
    }
}
```

单纯从功能实现角度来说，上面的代码没有问题，已经实现了我们想要的功能。但是，如果 我们开发的是一个大型系统，从扩展性（文件或目录可能会对应不同的操作）、业务建模 （文件和目录从业务上是两个概念）、代码的可读性（文件和目录区分对待更加符合人们对 业务的认知）的角度来说，我们最好对文件和目录进行区分设计，定义为 File 和 Directory 两个类。

```java
public abstract class FileSystemNode {
    protected String path;
    
    public FileSystemNode(String path) {
    	this.path = path;
    }
    
    public abstract int countNumOfFiles();
    
    public abstract long countSizeOfFiles();
    
    public String getPath() {
    	return path;
    }
}

public class File extends FileSystemNode {
    public File(String path) {
    	super(path);
    }
    
    @Override
    public int countNumOfFiles() {
    	return 1;
    }
    
    @Override
    public long countSizeOfFiles() {
        java.io.File file = new java.io.File(path);
        if (!file.exists()) return 0;
        return file.length();
    }
}

public class Directory extends FileSystemNode {
    private List<FileSystemNode> subNodes = new ArrayList<>();
    
    public Directory(String path) {
    	super(path);
    }
    
    @Override
    public int countNumOfFiles() {
        int numOfFiles = 0;
        for (FileSystemNode fileOrDir : subNodes) {
        	numOfFiles += fileOrDir.countNumOfFiles();
        }
        return numOfFiles;
    }
    
    @Override
    public long countSizeOfFiles() {
        long sizeofFiles = 0;
        for (FileSystemNode fileOrDir : subNodes) {
        	sizeofFiles += fileOrDir.countSizeOfFiles();
        }
        return sizeofFiles;
    }
    
    public void addSubNode(FileSystemNode fileOrDir) {
    	subNodes.add(fileOrDir);
    }
    
    public void removeSubNode(FileSystemNode fileOrDir) {
        int size = subNodes.size();
        int i = 0;
        for (; i < size; ++i) {
            if (subNodes.get(i).getPath().equalsIgnoreCase(fileOrDir.getPath())) {
            	break;
            }
        }
        if (i < size) {
        	subNodes.remove(i);
        }
    }
}
```

文件和目录类都设计好了，我们来看，如何用它们来表示一个文件系统中的目录树结构。具体的代码示例如下所示：

```java
public class Demo {
    public static void main(String[] args) {
    /**
    * /
    * /wz/
    * /wz/a.txt
    * /wz/b.txt
    * /wz/movies/
    * /wz/movies/c.avi
    * /xzg/
    * /xzg/docs/
    * /xzg/docs/d.txt
    */
    Directory fileSystemTree = new Directory("/");
    Directory node_wz = new Directory("/wz/");
    Directory node_xzg = new Directory("/xzg/");
    fileSystemTree.addSubNode(node_wz);
    fileSystemTree.addSubNode(node_xzg);
    File node_wz_a = new File("/wz/a.txt");
    File node_wz_b = new File("/wz/b.txt");
    Directory node_wz_movies = new Directory("/wz/movies/");
    node_wz.addSubNode(node_wz_a);
    node_wz.addSubNode(node_wz_b);
    node_wz.addSubNode(node_wz_movies);
    File node_wz_movies_c = new File("/wz/movies/c.avi");
    node_wz_movies.addSubNode(node_wz_movies_c);
    Directory node_xzg_docs = new Directory("/xzg/docs/");
    node_xzg.addSubNode(node_xzg_docs);
    File node_xzg_docs_d = new File("/xzg/docs/d.txt");
    node_xzg_docs.addSubNode(node_xzg_docs_d);
    System.out.println("/ files num:" + fileSystemTree.countNumOfFiles());
    System.out.println("/wz/ files num:" + node_wz.countNumOfFiles());
    }
}
```

组合模式的应用场景举例

有一个部门表和一个员工表，提供接口计算出部门的薪资成本（隶属于这个部门的所有员工的薪资和）

```java
public abstract class HumanResource {
    protected long id;
    protected double salary;
    
    public HumanResource(long id) {
    	this.id = id;
    }
    
    public long getId() {
    	return id;
    }
    
    public abstract double calculateSalary();
}

public class Employee extends HumanResource {
    public Employee(long id, double salary) {
    	super(id);
    	this.salary = salary;
    }
    
    @Override
    public double calculateSalary() {
    	return salary;
    }
}

public class Department extends HumanResource {
    private List<HumanResource> subNodes = new ArrayList<>();
    	public Department(long id) {
    	super(id);
    }
    
    @Override
    public double calculateSalary() {
    	double totalSalary = 0;
        for (HumanResource hr : subNodes) {
        	totalSalary += hr.calculateSalary();
        }
        this.salary = totalSalary;
        return totalSalary;
    }
    
    public void addSubNode(HumanResource hr) {
    	subNodes.add(hr);
    }
}

// 构建组织架构的代码
public class Demo {
    private static final long ORGANIZATION_ROOT_ID = 1001;
    
    private DepartmentRepo departmentRepo; // 依赖注入
    
    private EmployeeRepo employeeRepo; // 依赖注入
    
    public void buildOrganization() {
        Department rootDepartment = new Department(ORGANIZATION_ROOT_ID);
        buildOrganization(rootDepartment);
    }
    
    private void buildOrganization(Department department) {
        List<Long> subDepartmentIds = departmentRepo.getSubDepartmentIds(department
        for (Long subDepartmentId : subDepartmentIds) {
            Department subDepartment = new Department(subDepartmentId);
            department.addSubNode(subDepartment);
            buildOrganization(subDepartment);
    	}
                                                                         
        List<Long> employeeIds = employeeRepo.getDepartmentEmployeeIds(department.g
        for (Long employeeId : employeeIds) {
        double salary = employeeRepo.getEmployeeSalary(employeeId);
        department.addSubNode(new Employee(employeeId, salary));
        }
    }
}
```

#### 11. 享元模式

所谓“享元”，顾名思义就是被共享的单元。享元模式的意图是复用对象，节省内存，前提是享元对象是不可变对象。

具体来讲，当一个系统中存在大量重复对象的时候，如果这些重复的对象是不可变对象，我们就可以利用享元模式将对象设计成享元，在内存中只保留一份实例，供多处代码引用。这样可以减少内存中对象的数量，起到节省内存的目的。实际上，不仅仅相同对象可以设计成享元，对于相似对象，我们也可以将这些对象中相同的部分（字段）提取出来，设计成享元，让这些大量相似对象引用这些享元。

这里我稍微解释一下，定义中的“不可变对象”指的是，一旦通过构造函数初始化完成之后，它的状态（对象的成员变量或者属性）就不会再被修改了。所以，不可变对象不能暴露任何 set() 等修改内部状态的方法。之所以要求享元是不可变对象，那是因为它会被多处代码共享使用，避免一处代码对享元进行了修改，影响到其他使用它的代码。

举例：假设我们在开发一个棋牌游戏（比如象棋）。一个游戏厅中有成千上万个“房间”，每个房间对应一个棋局。棋局要保存每个棋子的数据，比如：棋子类型（将、相、士、炮等）、棋子颜色（红方、黑方）、棋子在棋局中的位置。利用这些数据，我们就能显示一个完整的棋盘给玩家。具体的代码如下所示。其中，ChessPiece 类表示棋子，ChessBoard 类表示一个棋局，里面保存了象棋中 30 个棋子的信息。

```java
public class ChessPiece { // 棋子
    private int id;
    private String text;
    private Color color;
    private int positionX;
    private int positionY;
    
    public ChessPiece(int id, String text, Color color, int positionX, int positionY) {
        this.id = id;
        this.text = text;
        this.color = color;
        this.positionX = positionX;
        this.positionY = positionX;
    }
    
    public static enum Color {
        RED, BLACK
    }
    
    // ...省略其他属性和getter/setter方法...
}

public class ChessBoard {//棋局
    private Map<Integer, ChessPiece> chessPieces = new HashMap<>();
    
    public ChessBoard() {
        init();
    }
    
    private void init() {
        chessPieces.put(1, new ChessPiece(1, "車", ChessPiece.Color.BLACK, 0, 0));
        chessPieces.put(2, new ChessPiece(2,"馬", ChessPiece.Color.BLACK, 0, 1));
        //...省略摆放其他棋子的代码...
    }
    
    public void move(int chessPieceId, int toPositionX, int toPositionY) {
        //...省略...
    }
}
```

为了记录每个房间当前的棋局情况，我们需要给每个房间都创建一个ChessBoard 棋局对象。因为游戏大厅中有成千上万的房间（实际上，百万人同时在线的游戏大厅也有很多），那保存这么多棋局对象就会消耗大量的内存。有没有什么办法来节省内存呢？

这个时候，享元模式就可以派上用场了。像刚刚的实现方式，在内存中会有大量的相似对象。这些相似对象的 id、text、color 都是相同的，唯独 positionX、positionY 不同。实际上，我们可以将棋子的 id、text、color 属性拆分出来，设计成独立的类，并且作为享元供多个棋盘复用。这样，棋盘只需要记录每个棋子的位置信息就可以了。具体的代码实现如下所示：

```java
// 享元类
public class ChessPieceUnit {
    private int id;
    private String text;
    private Color color;
    
    public ChessPieceUnit(int id, String text, Color color) {
        this.id = id;
        this.text = text;
        this.color = color;
    }
    
    public static enum Color {
        RED, BLACK
    }
    // ...省略其他属性和getter方法...
}

public class ChessPieceUnitFactory {
    private static final Map<Integer, ChessPieceUnit> pieces = new HashMap<>();
    
    static {
        pieces.put(1, new ChessPieceUnit(1, "車", ChessPieceUnit.Color.BLACK));
        pieces.put(2, new ChessPieceUnit(2, "馬", ChessPieceUnit.Color.BLACK));
        //...省略摆放其他棋子的代码...
    }
    
    public static ChessPieceUnit getChessPiece(int chessPieceId) {
        return pieces.get(chessPieceId);
    }
}

public class ChessPiece {
    private ChessPieceUnit chessPieceUnit;
    private int positionX;
    private int positionY;
    
    public ChessPiece(ChessPieceUnit unit, int positionX, int positionY) {
        this.chessPieceUnit = unit;
        this.positionX = positionX;
        this.positionY = positionY;
    }
    // 省略getter、setter方法
}

public class ChessBoard {
    private Map<Integer, ChessPiece> chessPieces = new HashMap<>();
    
    public ChessBoard() {
        init();
    }
    
    private void init() {
        chessPieces.put(1, new ChessPiece(ChessPieceUnitFactory.getChessPiece(1), 0,0));
        chessPieces.put(1, new ChessPiece(ChessPieceUnitFactory.getChessPiece(2), 1,0));
        //...省略摆放其他棋子的代码...
    }
    
    public void move(int chessPieceId, int toPositionX, int toPositionY) {
        //...省略...
    }
}
```

在上面的代码实现中，我们利用工厂类来缓存 ChessPieceUnit 信息（也就是 id、text、color）。通过工厂类获取到的 ChessPieceUnit 就是享元。所有的 ChessBoard 对象共享这 30 个 ChessPieceUnit 对象（因为象棋中只有 30 个棋子）。在使用享元模式之前，记录 1 万个棋局，我们要创建 30 万（30*1 万）个棋子的 ChessPieceUnit 对象。利用享元模式，我们只需要创建 30 个享元对象供所有棋局共享使用即可，大大节省了内存。
那享元模式的原理讲完了，我们来总结一下它的代码结构。实际上，它的代码实现非常简单，主要是通过工厂模式，在工厂类中，通过一个 Map 来缓存已经创建过的享元对象，来达到复用的目的。

享元模式在文本编辑器中的应用(简化的word)

对于简化之后的文本编辑器，我们要在内存中表示一个文本文件，只需要记录文字和格式两部分信息就可以了，其中，格式又包括文字的字体、大小、颜色等信息。

尽管在实际的文档编写中，我们一般都是按照文本类型（标题、正文……）来设置文字的格式，标题是一种格式，正文是另一种格式等等。但是，从理论上讲，我们可以给文本文件中的每个文字都设置不同的格式。为了实现如此灵活的格式设置，并且代码实现又不过于太复杂，我们把每个文字都当作一个独立的对象来看待，并且在其中包含它的格式信息。具体的代码示例如下所示：

```java
public class Character { // 文字
    private char c;
    private Font font;
    private int size;
    private int colorRGB;
    
    public Character(char c, Font font, int size, int colorRGB) {
        this.c = c;
        this.font = font;
        this.size = size;
        this.colorRGB = colorRGB;
    }
}

public class Editor {
    private List<Character> chars = new ArrayList<>();
    
    public void appendCharacter(char c, Font font, int size, int colorRGB) {
        Character character = new Character(c, font, size, colorRGB);
        chars.add(character);
    }
}
```

在文本编辑器中，我们每敲一个文字，都会调用 Editor 类中的appendCharacter() 方法，创建一个新的 Character 对象，保存到 chars 数组中。如果一个文本文件中，有上万、十几万、几十万的文字，那我们就要在内存中存储这么多 Character 对象。那有没有办法可以节省一点内存呢？实际上，在一个文本文件中，用到的字体格式不会太多，毕竟不大可能有人把每个文字都设置成不同的格式。所以，对于字体格式，我们可以将它设计成享元，让不同的文字共享使用。按照这个设计思路，我们对上面的代码进行重构。重构后的代码如下所示：

```java
public class CharacterStyle {
    private Font font;
    private int size;
    private int colorRGB;
    
    public CharacterStyle(Font font, int size, int colorRGB) {
        this.font = font;
        this.size = size;
        this.colorRGB = colorRGB;
    }
    
    @Override
    public boolean equals(Object o) {
        CharacterStyle otherStyle = (CharacterStyle) o;
        return font.equals(otherStyle.font)
            && size == otherStyle.size
            && colorRGB == otherStyle.colorRGB;
    }
}

public class CharacterStyleFactory {
    private static final List<CharacterStyle> styles = new ArrayList<>();
    
    public static CharacterStyle getStyle(Font font, int size, int colorRGB) {
        CharacterStyle newStyle = new CharacterStyle(font, size, colorRGB);
        for (CharacterStyle style : styles) {
            if (style.equals(newStyle)) {
                return style;
            }
        }
        styles.add(newStyle);
        return newStyle;
    }
}

public class Character {
    private char c;
    private CharacterStyle style;
    public Character(char c, CharacterStyle style) {
        this.c = c;
        this.style = style;
    }
}

public class Editor {
    private List<Character> chars = new ArrayList<>();
    
    public void appendCharacter(char c, Font font, int size, int colorRGB) {
        Character character = new Character(c, CharacterStyleFactory.getStyle(font, size, colorRGB));
        chars.add(character);
    }
}
```

##### 享元模式跟单例的区别

在单例模式中，一个类只能创建一个对象，而在享元模式中，一个类可以创建多个对象，每个对象被多处代码引用共享。实际上，享元模式有点类似于之前讲到的单例的变体：多例。我们前面也多次提到，区别两种设计模式，不能光看代码实现，而是要看设计意图，也就是要解决的问题。尽管从代码实现上来看，享元模式和多例有很多相似之处，但从设计意图上来看，它们是完全不同的。应用享元模式是为了对象复用，节省内存，而应用多例模式是为了限制对象的个数。

##### 看享元模式跟缓存的区别

在享元模式的实现中，我们通过工厂类来“缓存”已经创建好的对象。这里的“缓存”实际上是“存储”的意思，跟我们平时所说的“数据库缓存”“CPU 缓存”“MemCache 缓存”是两回事。我们平时所讲的缓存，主要是为了提高访问效率，而非复用。

##### 享元模式跟对象池的区别

池化技术中的“复用”可以理解为“重复使用”，主要目的是节省时间（比如从数据库池中取一个连接，不需要重新创建）。在任意时刻，每一个对象、连接、线程，并不会被多处使用，而是被一个使用者独占，当使用完成之后，放回到池中，再由其他使用者重复利用。享元模式中的“复用”可以理解为“共享使用”，在整个生命周期中，都是被所有使用者共享的，主要目的是节省空间。
