## 并发编程

### 1、可见性、原子性、有序性

- 可见性

  - 可以抽象出一个简单的模型，cpu有自己的缓存。单核cpu没有这个问题，而多个cpu，每个cpu有自己的缓存，都会导致可见性问题。

  - 缓存导致的可见性问题：

    ```java
    public class Test {
      private long count = 0;
      private void add10K() {
        int idx = 0;
        while(idx++ < 10000) {
          count += 1;
        }
      }
      public static long calc() throws InterruptedException {
        final Test test = new Test();
        // 创建两个线程，执行 add() 操作
        Thread th1 = new Thread(test::add10K);
        Thread th2 = new Thread(test::add10K);
        // 启动两个线程
        th1.start();
        th2.start();
        // 等待两个线程执行结束
        th1.join();
        th2.join();
        return test.count;
      }
    }
    ```

- 原子性

  - 把一个或者多个操作在 CPU 执行的过程中不被中断的特性称为原子性。

  - java写的一行代码，对应到CPU指令可能并不是一条。这就会导致java到一行代码不是原子性的。比如说count += 1;这行代码对应三个CPU指令，首先将变量count从内存加载到CPU到寄存器，然后在寄存器执行+1操作，最后将结果写入内存（缓存机制导致可能写入的是 CPU 缓存而不是内存）。操作系统做任务切换，可以发生在任何一条CPU 指令执行完。

  - 线程切换导致的原子性问题：

    | 线程A               | 线程B               |
    | ------------------- | ------------------- |
    | count=0加载到寄存器 |                     |
    | 线程切换            |                     |
    |                     | count=0加载到寄存器 |
    |                     | count+1=1           |
    |                     | count=1写入内存     |
    | count+1=1           |                     |
    | count=1写入内存     |                     |

- 有序性

  - 写好的java程序并不一定就是一行一行的执行，编译优化之后，顺序可能发生变化。

  - 编译优化带来的有序性问题

    ```java
    public class Singleton {
      static Singleton instance;
      static Singleton getInstance(){
        if (instance == null) {
          synchronized(Singleton.class) {
            if (instance == null)
              instance = new Singleton();
          }
        }
        return instance;
      }
    }
    ```

    我们认为的new执行过程是，先分配一块内存M，然后在内存M上初始化Singleton对象，最后M的地址赋值给instance对象。但是实际上，先分配一块内存M，然后M的地址赋值给instance变量，最后才是初始化singleton对象。

    | 线程A               | 线程B                    |
    | ------------------- | ------------------------ |
    | instance==null?true |                          |
    | 分配一块内存M       |                          |
    | instance=&M         |                          |
    |                     | instance==null?false     |
    |                     | 返回instance（未初始化） |

    